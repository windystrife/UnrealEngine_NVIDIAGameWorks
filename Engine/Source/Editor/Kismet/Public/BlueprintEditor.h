// Copyright 1998-2017 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Stats/Stats.h"
#include "EdGraph/EdGraphPin.h"
#include "UObject/GCObject.h"
#include "Layout/Visibility.h"
#include "Input/Reply.h"
#include "Widgets/SWidget.h"
#include "Styling/SlateBrush.h"
#include "Widgets/SWindow.h"
#include "PreviewScene.h"
#include "Framework/Commands/InputChord.h"
#include "Framework/Application/IMenu.h"
#include "Misc/NotifyHook.h"
#include "TickableEditorObject.h"
#include "EditorUndoClient.h"
#include "Toolkits/IToolkitHost.h"
#include "Toolkits/AssetEditorToolkit.h"
#include "WorkflowOrientedApp/WorkflowTabFactory.h"
#include "WorkflowOrientedApp/WorkflowTabManager.h"
#include "BlueprintEditorModule.h"
#include "GraphEditor.h"
#include "Developer/Merge/Public/Merge.h"

class FBlueprintEditorToolbar;
class FSCSEditorTreeNode;
class IMessageLogListing;
class INameValidatorInterface;
class ISCSEditorCustomization;
class SBlueprintPalette;
class SFindInBlueprints;
class SKismetDebuggingView;
class SKismetInspector;
class SMyBlueprint;
class SReplaceNodeReferences;
class SSCSEditor;
class SSCSEditorViewport;
class UEdGraph;
class UEdGraphNode;
class UUserDefinedEnum;
class UUserDefinedStruct;
struct Rect;

/////////////////////////////////////////////////////
// FCustomDebugObjectEntry - Used to pass a custom debug object override around

struct FCustomDebugObject
{
public:
	// Custom object to include, regardless of the current debugging World
	UObject* Object;

	// Override for the object name (if not empty)
	FString NameOverride;

public:
	FCustomDebugObject()
		: Object(NULL)
	{
	}

	FCustomDebugObject(UObject* InObject, const FString& InLabel)
		: Object(InObject)
		, NameOverride(InLabel)
	{
	}
};

/////////////////////////////////////////////////////
// FSelectionDetailsSummoner

#define LOCTEXT_NAMESPACE "BlueprintEditor"

struct KISMET_API FSelectionDetailsSummoner : public FWorkflowTabFactory
{
public:
	FSelectionDetailsSummoner(TSharedPtr<class FAssetEditorToolkit> InHostingApp);

	virtual TSharedRef<SWidget> CreateTabBody(const FWorkflowTabSpawnInfo& Info) const override;
	virtual TSharedRef<SDockTab> SpawnTab(const FWorkflowTabSpawnInfo& Info) const override;

	virtual FText GetTabToolTipText(const FWorkflowTabSpawnInfo& Info) const override
	{
		return LOCTEXT("SelectionDetailsTooltip", "The Details tab allows you see and edit properties of whatever is selected.");
	}
};

/////////////////////////////////////////////////////
// FComponentEventConstructionData

/** The structure used to construct the "Add Event" menu entries */
struct FComponentEventConstructionData
{
	// The name of the event handler to create.
	FName VariableName;
	// The template component that the handler applies to.
	TWeakObjectPtr<UObject> Component;
};

/** The delegate that the caller must supply to BuildComponentActionsSubMenu that returns the currently selected items */
DECLARE_DELEGATE_OneParam(FGetSelectedObjectsDelegate, TArray<FComponentEventConstructionData>&);

/** Delegate for Node Creation Analytics */
DECLARE_DELEGATE(FNodeCreationAnalytic);

/** Describes user actions that created new node */
namespace ENodeCreateAction
{
	enum Type
	{
		MyBlueprintDragPlacement,
		PaletteDragPlacement,
		GraphContext,
		PinContext,
		Keymap
	};
}

/////////////////////////////////////////////////////
// FBlueprintEditor

/** Main Kismet asset editor */
class KISMET_API FBlueprintEditor : public IBlueprintEditor, public FGCObject, public FNotifyHook, public FTickableEditorObject, public FEditorUndoClient
{
	DECLARE_MULTICAST_DELEGATE_OneParam(FOnSetPinVisibility, SGraphEditor::EPinVisibility);

	/** A record of a warning generated by a disallowed pin connection attempt */
	struct FDisallowedPinConnection
	{
		FString PinTypeCategoryA;
		bool bPinIsArrayA;
		bool bPinIsReferenceA;
		bool bPinIsWeakPointerA;

		FString PinTypeCategoryB;
		bool bPinIsArrayB;
		bool bPinIsReferenceB;
		bool bPinIsWeakPointerB;
	};

public:
	//~ Begin IToolkit Interface
	virtual void RegisterTabSpawners(const TSharedRef<class FTabManager>& TabManager) override;
	//~ End IToolkit Interface

	DECLARE_MULTICAST_DELEGATE_OneParam(FOnModeSet, FName);
	FOnModeSet& OnModeSet() { return OnModeSetData; }
	virtual void SetCurrentMode(FName NewMode) override;

public:
	/**
	 * Edits the specified blueprint
	 *
	 * @param	Mode					Asset editing mode for this editor (standalone or world-centric)
	 * @param	InitToolkitHost			When Mode is WorldCentric, this is the level editor instance to spawn this editor within
	 * @param	InBlueprints			The blueprints to edit
	 * @param	bShouldOpenInDefaultsMode	If true, the editor will open in defaults editing mode
	 */
	void InitBlueprintEditor(const EToolkitMode::Type Mode, const TSharedPtr< class IToolkitHost >& InitToolkitHost, const TArray<class UBlueprint*>& InBlueprints, bool bShouldOpenInDefaultsMode);

public:
	//~ Begin FAssetEditorToolkit Interface
	virtual bool OnRequestClose() override;
	virtual void ToolkitBroughtToFront() override;
	// End of FAssetEditorToolkit 

	//~ Begin IToolkit Interface
	virtual FName GetToolkitContextFName() const override;
	virtual FName GetToolkitFName() const override;
	virtual FText GetBaseToolkitName() const override;
	virtual FText GetToolkitName() const override;
	virtual FText GetToolkitToolTipText() const override;
	virtual FString GetWorldCentricTabPrefix() const override;
	virtual FLinearColor GetWorldCentricTabColorScale() const override;
	virtual bool IsBlueprintEditor() const override;
	//~ End IToolkit Interface

	//~ Begin FGCObject Interface
	virtual void AddReferencedObjects(FReferenceCollector& Collector) override;
	//~ End FGCObject Interface

	//~ Begin IBlueprintEditor Interface
	virtual void RefreshEditors(ERefreshBlueprintEditorReason::Type Reason = ERefreshBlueprintEditorReason::UnknownReason) override;
	virtual void AddToSelection(UEdGraphNode* InNode) override;
	virtual void JumpToHyperlink(const UObject* ObjectReference, bool bRequestRename = false) override;
	virtual void JumpToPin(const class UEdGraphPin* Pin) override;
	virtual void SummonSearchUI(bool bSetFindWithinBlueprint, FString NewSearchTerms = FString(), bool bSelectFirstResult = false) override;
	virtual void SummonFindAndReplaceUI() override;
	virtual TArray<TSharedPtr<class FSCSEditorTreeNode> > GetSelectedSCSEditorTreeNodes() const override;
	virtual TSharedPtr<class FSCSEditorTreeNode> FindAndSelectSCSEditorTreeNode(const UActorComponent* InComponent, bool IsCntrlDown) override;
	virtual int32 GetNumberOfSelectedNodes() const override;
	virtual void AnalyticsTrackNodeEvent(UBlueprint* Blueprint, UEdGraphNode *GraphNode, bool bNodeDelete = false) const override;
	void AnalyticsTrackCompileEvent(UBlueprint* Blueprint, int32 NumErrors, int32 NumWarnings) const;
	//~ End IBlueprintEditor Interface

	//~ Begin FTickableEditorObject Interface
	virtual void Tick(float DeltaTime) override;
	virtual bool IsTickable() const override { return true; }
	virtual TStatId GetStatId() const override;
	//~ End FTickableEditorObject Interface

public:
	FBlueprintEditor();

	virtual ~FBlueprintEditor();

	/** Check the Node Title is visible */
	bool IsNodeTitleVisible(const UEdGraphNode* Node, bool bRequestRename);

	/** Pan the view to center on a particular node */
	void JumpToNode(const class UEdGraphNode* Node, bool bRequestRename = false);

	/** Returns a pointer to the Blueprint object we are currently editing, as long as we are editing exactly one */
	virtual UBlueprint* GetBlueprintObj() const;

	/**	Returns whether the editor is currently editing a single blueprint object */
	bool IsEditingSingleBlueprint() const;

	/** Getters for the various Kismet2 widgets */
	TSharedRef<class SKismetInspector> GetInspector() const { return Inspector.ToSharedRef(); }
	TSharedRef<class SKismetInspector> GetDefaultEditor() const { return DefaultEditor.ToSharedRef(); }
	TSharedRef<class SKismetDebuggingView> GetDebuggingView() const { return DebuggingView.ToSharedRef(); }
	TSharedRef<class SBlueprintPalette> GetPalette() const { return Palette.ToSharedRef(); }
	TSharedRef<class SWidget> GetCompilerResults() const { return CompilerResults.ToSharedRef(); }
	TSharedRef<class SFindInBlueprints> GetFindResults() const { return FindResults.ToSharedRef(); }

	/** Getters for the various optional Kismet2 widgets */
	TSharedPtr<class SSCSEditor> GetSCSEditor() const { return SCSEditor; }
	TSharedPtr<class SSCSEditorViewport> GetSCSViewport() const { return SCSViewport; }
	TSharedPtr<class SMyBlueprint> GetMyBlueprintWidget() const { return MyBlueprintWidget; }
	TSharedPtr<class SReplaceNodeReferences> GetReplaceReferencesWidget() const { return ReplaceReferencesWidget; }

	/**
	 * Provides access to the preview actor.
	 */
	AActor* GetPreviewActor() const;

	/**
	 * Provides access to the preview scene.
	 */
	FPreviewScene* GetPreviewScene()
	{
		return &PreviewScene;
	}

	/**
	* Creates/updates the preview actor for the given blueprint.
	*
	* @param InBlueprint			The Blueprint to create or update the preview for.
	* @param bInForceFullUpdate	Force a full update to respawn actors.
	*/
	void UpdatePreviewActor(UBlueprint* InBlueprint, bool bInForceFullUpdate = false);

	/**
	* Destroy the Blueprint preview.
	*/
	void DestroyPreview();

	TSharedPtr<class FBlueprintEditorToolbar> GetToolbarBuilder() { return Toolbar; }

	/** @return the documentation location for this editor */
	virtual FString GetDocumentationLink() const override;

	/**	Returns whether the edited blueprint has components */
	bool CanAccessComponentsMode() const;

	// @todo This is a hack for now until we reconcile the default toolbar with application modes
	void RegisterToolbarTab(const TSharedRef<class FTabManager>& TabManager);
	/** Throw a simple message into the log */
	void LogSimpleMessage(const FText& MessageText);

	/** Dumps messages to the compiler log, with an option to force it to display/come to front */
	void DumpMessagesToCompilerLog(const TArray<TSharedRef<class FTokenizedMessage>>& Messages, bool bForceMessageDisplay);

	/** Returns true if in debugging mode */
	bool InDebuggingMode() const;

	/** Get the currently selected set of nodes */
	TSet<UObject*> GetSelectedNodes() const;

	/** Returns the currently selected node if there is a single node selected (if there are multiple nodes selected or none selected, it will return nullptr) */
	UEdGraphNode* GetSingleSelectedNode() const;

	/** Save the current set of edited objects in the LastEditedObjects array so it will be opened next time we open K2 */
	void SaveEditedObjectState();

	/** Create new tab for each element of LastEditedObjects array */
	void RestoreEditedObjectState();

	// Request a save of the edited object state
	// This is used to delay it by one frame when triggered by a tab being closed, so it can finish closing before remembering the new state
	void RequestSaveEditedObjectState();

	/** Returns whether a graph is editable or not */
	virtual bool IsEditable(UEdGraph* InGraph) const;
	/** Determines if the graph is ReadOnly, this differs from editable in that it is never expected to be edited and is in a read-only state */
	bool IsGraphReadOnly(UEdGraph* InGraph) const;

	/** Used to determine the visibility of the graph's instruction text. */
	float GetInstructionTextOpacity(UEdGraph* InGraph) const;

	/** Returns true if in editing mode */
	bool InEditingMode() const;

	/** Returns true if able to compile */
	bool IsCompilingEnabled() const;

	/** Returns true if the parent class is also a Blueprint */
	bool IsParentClassOfObjectABlueprint(const UBlueprint* Blueprint) const;

	/** Returns true if the parent class of the Blueprint being edited is also a Blueprint */
	bool IsParentClassABlueprint() const;

	/** Returns true if the parent class of the Blueprint being edited is native */
	bool IsParentClassNative() const;

	/** Returns true if the parent class is native and the link to it's header can be shown*/
	bool IsNativeParentClassCodeLinkEnabled() const;

	/** Handles opening the header file of native parent class */
	void OnEditParentClassNativeCodeClicked();

	/** Returns: "(<NativeParentClass>.h)" */
	FText GetTextForNativeParentClassHeaderLink() const;

	/** Determines visibility of the native parent class manipulation buttons on the menu bar overlay */
	EVisibility GetNativeParentClassButtonsVisibility() const;

	/** Determines visibility of the standard parent class label on the menu bar overlay */
	EVisibility GetParentClassNameVisibility() const;

	/** Returns our PIE Status - SIMULATING / SERVER / CLIENT */
	FText GetPIEStatus() const;

	/**
	 * Util for finding a glyph for a graph
	 *
	 * @param Graph - The graph to evaluate
	 * @param bInLargeIcon - if true the icon returned is 22x22 pixels, else it is 16x16
	 * @return An appropriate brush to use to represent the graph, if the graph is an unknown type the function will return the default "function" glyph
	 */
	static const FSlateBrush* GetGlyphForGraph(const UEdGraph* Graph, bool bInLargeIcon = false);

	/**
	 * Util for finding a glyph and color for a variable.
	 *
	 * @param VarScope			Scope to find the variable in
	 * @param VarName			Name of variable
	 * @param IconColorOut		The resulting color for the glyph
	 * @return					The resulting glyph brush
	 */
	static FSlateBrush const* GetVarIconAndColor(const UStruct* VarScope, FName VarName, FSlateColor& IconColorOut, FSlateBrush const*& SecondaryBrushOut, FSlateColor& SecondaryColorOut);

	/** Overridable function for determining if the current mode can script */
	virtual bool IsInAScriptingMode() const;

	/** Called when Compile button is clicked */
	virtual void Compile();

	/** Helper functions used to construct/operate-on the "Save on Compile" command */
	bool IsSaveOnCompileEnabled() const;

	/** Calls the above function, but returns an FReply::Handled(). Used in SButtons */
	virtual FReply Compile_OnClickWithReply();

	/** Called when the refresh all nodes button is clicked */
	void RefreshAllNodes_OnClicked();

	EVisibility IsDebuggerVisible() const;

	virtual void OnActiveTabChanged(TSharedPtr<SDockTab> PreviouslyActive, TSharedPtr<SDockTab> NewlyActivated);

	/** Called when a token in a log message is clicked */
	void LogToken_OnClicked(const class IMessageToken& Token);

	void FocusInspectorOnGraphSelection(const TSet<class UObject*>& NewSelection, bool bForceRefresh = false);

	/** Variable list window calls this after it is updated */
	void VariableListWasUpdated();

	/** Virtual override point for editing defaults; allowing more derived editors to edit something else */
	virtual void StartEditingDefaults(bool bAutoFocus = true, bool bForceRefresh = false);

	// Called by the blueprint editing app mode to focus the appropriate tabs, etc...
	void SetupViewForBlueprintEditingMode();

	// Ensures the blueprint is up to date
	void EnsureBlueprintIsUpToDate(UBlueprint* BlueprintObj);

	// Should be called when initializing any editor built off this foundation
	void CommonInitialization(const TArray<UBlueprint*>& InitBlueprints);

	// Should be called when initializing an editor that has a blueprint, after layout (tab spawning) is done
	void PostLayoutBlueprintEditorInitialization();

	/** Called when graph editor focus is changed */
	virtual void OnGraphEditorFocused(const TSharedRef<class SGraphEditor>& InGraphEditor);

	/** Called when the graph editor tab is backgrounded */
	virtual void OnGraphEditorBackgrounded(const TSharedRef<SGraphEditor>& InGraphEditor);

	/** Enable/disable the SCS editor preview viewport */
	void EnableSCSPreview(bool bEnable);

	/** Refresh the preview viewport to reflect changes in the SCS */
	void UpdateSCSPreview(bool bUpdateNow = false);

	/** Delegate invoked when the SCS editor needs to obtain the Actor context for editing */
	AActor* GetSCSEditorActorContext() const;

	/** Delegate invoked when the selection is changed in the SCS editor widget */
	void OnSelectionUpdated(const TArray<TSharedPtr<class FSCSEditorTreeNode>>& SelectedNodes);

	/** Delegate invoked when an item is double clicked in the SCS editor widget */
	void OnComponentDoubleClicked(TSharedPtr<class FSCSEditorTreeNode> Node);

	/** Pin visibility accessors */
	void SetPinVisibility(SGraphEditor::EPinVisibility Visibility);
	bool GetPinVisibility(SGraphEditor::EPinVisibility Visibility) const { return PinVisibility == Visibility; }

	/** Reparent the current blueprint */
	void ReparentBlueprint_Clicked();
	bool ReparentBlueprint_IsVisible() const;
	void ReparentBlueprint_NewParentChosen(UClass* ChosenClass);

	/** Utility function to handle all steps required to rename a newly added action */
	void RenameNewlyAddedAction(FName InActionName);

	/** Adds a new variable to this blueprint */
	void OnAddNewVariable();
	FReply OnAddNewVariable_OnClick() { OnAddNewVariable(); return FReply::Handled(); }

	/** Checks if adding a local variable is allowed in the focused graph */
	bool CanAddNewLocalVariable() const;

	/** Adds a new local variable to the focused function graph */
	void OnAddNewLocalVariable();

	// Type of new document/graph being created by a menu item
	enum ECreatedDocumentType
	{
		CGT_NewVariable,
		CGT_NewFunctionGraph,
		CGT_NewMacroGraph,
		CGT_NewAnimationGraph,
		CGT_NewEventGraph,
		CGT_NewLocalVariable
	};

	/** Called when New Function button is clicked */
	void NewDocument_OnClicked(ECreatedDocumentType GraphType);
	FReply NewDocument_OnClick(ECreatedDocumentType GraphType) { NewDocument_OnClicked(GraphType); return FReply::Handled(); }

	/** Called when New Delegate button is clicked */
	void OnAddNewDelegate();
	bool AddNewDelegateIsVisible() const;

	// Called to see if the new document menu items is visible for this type
	bool NewDocument_IsVisibleForType(ECreatedDocumentType GraphType) const;
	EVisibility NewDocument_GetVisibilityForType(ECreatedDocumentType GraphType) const
	{
		return NewDocument_IsVisibleForType(GraphType) ? EVisibility::Visible : EVisibility::Collapsed;
	}

	static FName SelectionState_MyBlueprint;
	static FName SelectionState_Components;
	static FName SelectionState_Graph;
	static FName SelectionState_ClassSettings;
	static FName SelectionState_ClassDefaults;

	/** Gets or sets the flag for context sensitivity in the graph action menu */
	bool& GetIsContextSensitive() { return bIsActionMenuContextSensitive; }

	/** Gets the UI selection state of this editor */
	FName GetUISelectionState() const { return CurrentUISelection; }
	void SetUISelectionState(FName SelectionOwner);

	virtual void ClearSelectionStateFor(FName SelectionOwner);

	/** Handles spawning a graph node in the current graph using the passed in chord */
	FReply OnSpawnGraphNodeByShortcut(FInputChord InChord, const FVector2D& InPosition, UEdGraph* InGraph);

	/**
	 * Perform the actual promote to variable action on the given pin in the given blueprint.
	 *
	 * @param	InBlueprint				The blueprint in which to create the variable.
	 * @param	InTargetPin				The pin on which to base the variable.
	 * @param	bInToMemberVariable		TRUE if attempting to create a member variable, FALSE if the variable should be local
	 */
	void DoPromoteToVariable(UBlueprint* InBlueprint, UEdGraphPin* InTargetPin, bool bInToMemberVariable);

	/** Called when node is spawned by keymap */
	void OnNodeSpawnedByKeymap();

	/** Update Node Creation mechanisms for analytics */
	void UpdateNodeCreationStats(const ENodeCreateAction::Type CreateAction);

	/**
	 * Register a customization for interacting with the SCS editor
	 * @param	InComponentName			The name of the component to customize behavior for
	 * @param	InCustomization			The customization instance to use
	 */
	void RegisterSCSEditorCustomization(const FName& InComponentName, TSharedPtr<class ISCSEditorCustomization> InCustomization);

	/**
	 * Unregister a previously registered customization for interacting with the SCS editor
	 * @param	InComponentName			The name of the component to customize behavior for
	 */
	void UnregisterSCSEditorCustomization(const FName& InComponentName);

	/** Forces the merge tool to be shown */
	void CreateMergeToolTab();
	void CreateMergeToolTab(const UBlueprint* BaseBlueprint, const UBlueprint* RemoteBlueprint, const FOnMergeResolved& ResolutionCallback);

	/** Closes the merge tool, rather than simply hiding it */
	void CloseMergeTool();

	/** Opens a native code generation modal window */
	void OpenNativeCodeGenerationTool();

	/** Can generate native code for current blueprint */
	bool CanGenerateNativeCode() const;

	/**
	 * Check to see if we can customize the SCS editor for the passed-in scene component
	 * @param	InComponentToCustomize	The component to check to see if a customization exists
	 * @return an SCS editor customization instance, if one exists.
	 */
	TSharedPtr<class ISCSEditorCustomization> CustomizeSCSEditor(USceneComponent* InComponentToCustomize) const;

	/**
	 * Returns the currently focused graph in the Blueprint editor
	 */
	UEdGraph* GetFocusedGraph() const;

	/** Adds to a list of custom objects for debugging beyond what will automatically be found/used */
	virtual void GetCustomDebugObjects(TArray<FCustomDebugObject>& DebugList) const { }

	/** Called when a node's title is committed for a rename */
	void OnNodeTitleCommitted(const FText& NewText, ETextCommit::Type CommitInfo, UEdGraphNode* NodeBeingChanged);

	/** Called by a graph title bar to get any extra information the editor would like to display */
	virtual FText GetGraphDecorationString(UEdGraph* InGraph) const;

	/** Checks to see if the provided graph is contained within the current blueprint */
	bool IsGraphInCurrentBlueprint(UEdGraph* InGraph) const;

	/** Get the context to use from the Blueprint type */
	static FName GetContextFromBlueprintType(EBlueprintType InType);

	/* Selects an item in "My Blueprint" by name. */
	void SelectGraphActionItemByName(const FName& ItemName, ESelectInfo::Type SelectInfo = ESelectInfo::Direct, int32 SectionId = INDEX_NONE, bool bIsCategory = false);

	/** Handle when the debug object is changed in the UI */
	virtual void HandleSetObjectBeingDebugged(UObject* InObject) {}

protected:
	virtual void AppendExtraCompilerResults(TSharedPtr<class IMessageLogListing> ResultsListing);

	/** Called during initialization of the blueprint editor to register any application modes. */
	virtual void RegisterApplicationModes(const TArray<UBlueprint*>& InBlueprints, bool bShouldOpenInDefaultsMode, bool bNewlyCreated = false);

	// Updates the selected object used by the stand lone defaults editor widget.
	void RefreshStandAloneDefaultsEditor();

	// Zooming to fit the entire graph
	void ZoomToWindow_Clicked();
	bool CanZoomToWindow() const;

	// Zooming to fit the current selection
	void ZoomToSelection_Clicked();
	bool CanZoomToSelection() const;

	// Navigating into/out of graphs
	void NavigateToParentGraph_Clicked();
	bool CanNavigateToParentGraph() const;
	void NavigateToChildGraph_Clicked();
	bool CanNavigateToChildGraph() const;

	/** Determines visibility of the parent class manipulation buttons on the menu bar overlay */
	EVisibility ParentClassButtonsVisibility() const;

	/** Recreates the overlay on the menu bar */
	virtual void PostRegenerateMenusAndToolbars() override;

	/** Returns the name of the Blueprint's parent class */
	FText GetParentClassNameText() const;

	/** Handler for "Find parent class in CB" button */
	FReply OnFindParentClassInContentBrowserClicked();

	/** Handler for "Edit parent class" button */
	FReply OnEditParentClassClicked();

	/** Called to start a quick find (focus the search box in the explorer tab) */
	void FindInBlueprint_Clicked();

	// Is the main details panel currently showing 'Global options' (e.g., class metadata)?
	bool IsDetailsPanelEditingGlobalOptions() const;

	/** Edit the class settings aka Blueprint global options */
	void EditGlobalOptions_Clicked();

	// Is the main details panel currently showing 'Class defaults' (Note: Has nothing to do with the standalone class defaults panel)?
	bool IsDetailsPanelEditingClassDefaults() const;

	/** Edit the class defaults */
	void EditClassDefaults_Clicked();

	/** Called to undo the last action */
	void UndoGraphAction();

	/** Whether or not we can perform an undo of the last transacted action */
	bool CanUndoGraphAction() const;

	/** Called to redo the last undone action */
	void RedoGraphAction();

	/** Whether or not we can redo an undone action */
	bool CanRedoGraphAction() const;
	
	/** Called when the selection changes in the GraphEditor */
	virtual void OnSelectedNodesChangedImpl(const TSet<class UObject*>& NewSelection);

	/** Called when the selection changes in the GraphEditor */
	void OnSelectedNodesChanged(const TSet<class UObject*>& NewSelection) { OnSelectedNodesChangedImpl(NewSelection); }

	/** Called when an actor is dropped onto the graph editor */
	void OnGraphEditorDropActor(const TArray< TWeakObjectPtr<AActor> >& Actors, UEdGraph* Graph, const FVector2D& DropLocation);

	/** Called when a streaming level is dropped onto the graph editor */
	void OnGraphEditorDropStreamingLevel(const TArray< TWeakObjectPtr<ULevelStreaming> >& Levels, UEdGraph* Graph, const FVector2D& DropLocation);

	/** Called to create context menu when right-clicking on graph */
	FActionMenuContent OnCreateGraphActionMenu(UEdGraph* InGraph, const FVector2D& InNodePosition, const TArray<UEdGraphPin*>& InDraggedPins, bool bAutoExpand, SGraphEditor::FActionMenuClosed InOnMenuClosed);

	/** Called from graph context menus when they close to tell the editor why they closed */
	void OnGraphActionMenuClosed(bool bActionExecuted, bool bContextSensitiveChecked, bool bGraphPinContext);

	/** Called when the Blueprint we are editing has changed */
	virtual void OnBlueprintChangedImpl(UBlueprint* InBlueprint, bool bIsJustBeingCompiled = false);

	/** Called when the Blueprint we are editing has changed, forwards to impl */
	void OnBlueprintChanged(UBlueprint* InBlueprint) { return OnBlueprintChangedImpl(InBlueprint); }

	void OnBlueprintCompiled(UBlueprint* InBlueprint);

	/** Handles the unloading of Blueprints (by closing the editor, if it operating on the Blueprint being unloaded)*/
	void OnBlueprintUnloaded(UBlueprint* InBlueprint);

	//@TODO: Should the breakpoint/watch modification operations be whole-blueprint, or current-graph?

	/** Deletes all breakpoints for the blueprint being edited */
	void ClearAllBreakpoints();

	/** Disables all breakpoints for the blueprint being edited */
	void DisableAllBreakpoints();

	/** Enables all breakpoints for the blueprint being edited */
	void EnableAllBreakpoints();

	/** Clears all watches associated with the blueprint being edited */
	void ClearAllWatches();

	bool HasAnyBreakpoints() const;
	bool HasAnyEnabledBreakpoints() const;
	bool HasAnyDisabledBreakpoints() const;
	bool HasAnyWatches() const;

	// Utility helper to get the currently hovered pin in the currently visible graph, or NULL if there isn't one
	UEdGraphPin* GetCurrentlySelectedPin() const;

	// UI Action functionality
	void OnPromoteToVariable(bool bInToMemberVariable);
	bool CanPromoteToVariable(bool bInToMemberVariable) const;

	void OnSplitStructPin();
	bool CanSplitStructPin() const;

	void OnRecombineStructPin();
	bool CanRecombineStructPin() const;

	void OnAddExecutionPin();
	bool CanAddExecutionPin() const;

	void OnRemoveExecutionPin();
	bool CanRemoveExecutionPin() const;

	void OnRemoveThisStructVarPin();
	bool CanRemoveThisStructVarPin() const;

	void OnRemoveOtherStructVarPins();
	bool CanRemoveOtherStructVarPins() const;

	void OnRestoreAllStructVarPins();
	bool CanRestoreAllStructVarPins() const;

	void OnResetPinToDefaultValue();
	bool CanResetPinToDefaultValue() const;

	void OnAddOptionPin();
	bool CanAddOptionPin() const;

	void OnRemoveOptionPin();
	bool CanRemoveOptionPin() const;

	/** Functions for handling the changing of the pin's type (PinCategory, PinSubCategory, etc) */
	FEdGraphPinType OnGetPinType(UEdGraphPin* SelectedPin) const;
	void OnChangePinType();
	void OnChangePinTypeFinished(const FEdGraphPinType& PinType, UEdGraphPin* SelectedPin);
	bool CanChangePinType() const;

	void OnAddParentNode();
	bool CanAddParentNode() const;

	void OnEnableBreakpoint();
	bool CanEnableBreakpoint() const;

	void OnToggleBreakpoint();
	bool CanToggleBreakpoint() const;

	void OnDisableBreakpoint();
	bool CanDisableBreakpoint() const;

	void OnAddBreakpoint();
	bool CanAddBreakpoint() const;

	void OnRemoveBreakpoint();
	bool CanRemoveBreakpoint() const;

	void OnCollapseNodes();
	bool CanCollapseNodes() const;

	void OnCollapseSelectionToFunction();
	bool CanCollapseSelectionToFunction() const;

	void OnCollapseSelectionToMacro();
	bool CanCollapseSelectionToMacro() const;

	void OnPromoteSelectionToFunction();
	bool CanPromoteSelectionToFunction() const;

	void OnPromoteSelectionToMacro();
	bool CanPromoteSelectionToMacro() const;

	void OnExpandNodes();
	bool CanExpandNodes() const;

	void OnAlignTop();
	void OnAlignMiddle();
	void OnAlignBottom();
	void OnAlignLeft();
	void OnAlignCenter();
	void OnAlignRight();

	void OnStraightenConnections();

	void OnDistributeNodesH();
	void OnDistributeNodesV();

	void SelectAllNodes();
	bool CanSelectAllNodes() const;

	void DeleteSelectedNodes();
	bool CanDeleteNodes() const;

	void DeleteSelectedDuplicatableNodes();

	void CutSelectedNodes();
	bool CanCutNodes() const;

	void CopySelectedNodes();
	bool CanCopyNodes() const;

	/** Paste on graph at specific location */
	virtual void PasteNodesHere(class UEdGraph* DestinationGraph, const FVector2D& GraphLocation) override;

	void PasteNodes();
	virtual bool CanPasteNodes() const override;

	void DuplicateNodes();
	bool CanDuplicateNodes() const;

	void OnSelectReferenceInLevel();
	bool CanSelectReferenceInLevel() const;

	void OnAssignReferencedActor();
	bool CanAssignReferencedActor() const;

	void OnStartWatchingPin();
	bool CanStartWatchingPin() const;

	void OnStopWatchingPin();
	bool CanStopWatchingPin() const;

	/**  BEGIN PERSONA related callback functions */
	virtual void OnSelectBone() {};
	virtual bool CanSelectBone() const { return false; }

	virtual void OnAddPosePin() {};
	virtual bool CanAddPosePin() const { return false; }

	virtual void OnMergeAnimStateTransitions() {};
	virtual bool CanMergeAnimStateTransitions() const { return false; }

	virtual void OnRemovePosePin() {};
	virtual bool CanRemovePosePin() const { return false; }

	// convert functions between evaluator and player
	virtual void OnConvertToSequenceEvaluator() {};
	virtual void OnConvertToSequencePlayer() {};
	virtual void OnConvertToBlendSpaceEvaluator() {};
	virtual void OnConvertToBlendSpacePlayer() {};
	virtual void OnConvertToAimOffsetLookAt() {};
	virtual void OnConvertToAimOffsetSimple() {};
	virtual void OnConvertToPoseBlender() {};
	virtual void OnConvertToPoseByName() {};

	// Opens the associated asset of the selected nodes
	virtual void OnOpenRelatedAsset() {};
	/** END PERSONA related callback functions */

	void ToggleSaveIntermediateBuildProducts();
	bool GetSaveIntermediateBuildProducts() const;

	void OnListObjectsReferencedByClass();
	void OnListObjectsReferencedByBlueprint();
	void OnRepairCorruptedBlueprint();

	void OnNodeDoubleClicked(UEdGraphNode* Node);

	virtual void OnEditTabClosed(TSharedRef<SDockTab> Tab);

	virtual bool GetBoundsForSelectedNodes(class FSlateRect& Rect, float Padding) override;

	/**
	 * Pulls out the pins to use as a template when collapsing a selection to a function with a custom event involved.
	 *
	 * @param InCustomEvent				The custom event used as a template
	 * @param InGatewayNode				The node replacing the selection of nodes
	 * @param InEntryNode				The entry node in the graph
	 * @param InResultNode				The result node in the graph
	 * @param InCollapsableNodes		The selection of nodes being collapsed
	 */
	void ExtractEventTemplateForFunction(class UK2Node_CustomEvent* InCustomEvent, UEdGraphNode* InGatewayNode, class UK2Node_EditablePinBase* InEntryNode, class UK2Node_EditablePinBase* InResultNode, TSet<UEdGraphNode*>& InCollapsableNodes);

	/**
	 * Collapses a selection of nodes into a graph for composite, function, or macro nodes.
	 *
	 * @param InGatewayNode				The node replacing the selection of nodes
	 * @param InEntryNode				The entry node in the graph
	 * @param InResultNode				The result node in the graph
	 * @param InSourceGraph				The graph the selection is from
	 * @param InDestinationGraph		The destination graph to move the selected nodes to
	 * @param InCollapsableNodes		The selection of nodes being collapsed
	 */
	void CollapseNodesIntoGraph(UEdGraphNode* InGatewayNode, class UK2Node_EditablePinBase* InEntryNode, class UK2Node_EditablePinBase* InResultNode, UEdGraph* InSourceGraph, UEdGraph* InDestinationGraph, TSet<UEdGraphNode*>& InCollapsableNodes, bool bCanDiscardEmptyReturnNode, bool bCanHaveWeakObjPtrParam);

	/** Called when a selection of nodes are being collapsed into a sub-graph */
	void CollapseNodes(TSet<class UEdGraphNode*>& InCollapsableNodes);

	/** Called when a selection of nodes are being collapsed into a function */
	UEdGraph* CollapseSelectionToFunction(TSharedPtr<SGraphEditor> InRootGraph, TSet<class UEdGraphNode*>& InCollapsableNodes, UEdGraphNode*& OutFunctionNode);

	/** Called when a selection of nodes are being collapsed into a macro */
	UEdGraph* CollapseSelectionToMacro(TSharedPtr<SGraphEditor> InRootGraph, TSet<class UEdGraphNode*>& InCollapsableNodes, UEdGraphNode*& OutMacroNode);

	/**
	 * Called when a selection of nodes is being collapsed into a function
	 *
	 * @param InSelection		The selection to check
	 *
	 * @return					Returns TRUE if the selection can be promoted to a function
	 */
	bool CanCollapseSelectionToFunction(TSet<class UEdGraphNode*>& InSelection) const;

	/**
	 * Called when a selection of nodes is being collapsed into a macro
	 *
	 * @param InSelection		The selection to check
	 *
	 * @return					Returns TRUE if the selection can be promoted to a macro
	 */
	bool CanCollapseSelectionToMacro(TSet<class UEdGraphNode*>& InSelection) const;

	/**
	 * Expands passed in node */
	static void ExpandNode(UEdGraphNode* InNodeToExpand, UEdGraph* InSourceGraph, TSet<UEdGraphNode*>& OutExpandedNodes);

	/** Start editing the defaults for this blueprint */
	void OnStartEditingDefaultsClicked();

	/** Creates the widgets that go into the tabs (note: does not create the tabs themselves) **/
	virtual void CreateDefaultTabContents(const TArray<UBlueprint*>& InBlueprints);

	/** Create Default Commands **/
	virtual void CreateDefaultCommands();

	/** Called when DeleteUnusedVariables button is clicked */
	void DeleteUnusedVariables_OnClicked();

	/** Called when Find In Blueprints menu is opened is clicked */
	void FindInBlueprints_OnClicked();

	//~ Begin FNotifyHook Interface
	virtual void NotifyPreChange( UProperty* PropertyAboutToChange ) override;
	virtual void NotifyPostChange( const FPropertyChangedEvent& PropertyChangedEvent, UProperty* PropertyThatChanged) override;
	//~ End FNotifyHook Interface

	/** Callback when properties have finished being handled */
	void OnFinishedChangingProperties(const FPropertyChangedEvent& PropertyChangedEvent);

	/** On starting to rename node */
	void OnRenameNode();
	bool CanRenameNodes() const;

	/* Renames a GraphNode */
	void RenameGraph(class UEdGraphNode* GraphNode, const FString& NewName);

	/** Called when a node's title is being committed for a rename so it can be verified */
	bool OnNodeVerifyTitleCommit(const FText& NewText, UEdGraphNode* NodeBeingChanged, FText& OutErrorMessage);

	/**Load macro & function blueprint libraries from asset registry*/
	void LoadLibrariesFromAssetRegistry();

	//~ Begin FEditorUndoClient Interface
	virtual void	PostUndo(bool bSuccess) override;
	virtual void	PostRedo(bool bSuccess) override;
	// End of FEditorUndoClient

	/** Get the graph appearance of the currently focused graph */
	FGraphAppearanceInfo GetCurrentGraphAppearance() const;

	/** Get the graph appearance of a specific graph, GetCurrentGraphAppearance() uses the currently focused graph. */
	virtual FGraphAppearanceInfo GetGraphAppearance(class UEdGraph* InGraph) const;

	/** Whenever new graphs need to be created it will use this schema by default. */
	virtual TSubclassOf<UEdGraphSchema> GetDefaultSchemaClass() const;

	/** Attempts to invoke the details tab if it's currently possible to. */
	void TryInvokingDetailsTab(bool bFlash = true);

private:

	/** Returns true if modules can be recompiled */
	static bool CanRecompileModules();

	/* User wants to edit tunnel via function editor */
	void OnEditTunnel();

	/* Create comment node on graph */
	void OnCreateComment();

	// Create new graph editor widget for the supplied document container
	TSharedRef<SGraphEditor> CreateGraphEditorWidget(TSharedRef<class FTabInfo> InTabInfo, class UEdGraph* InGraph);

	/** Helper to move focused graph when clicking on graph breadcrumb */
	void OnChangeBreadCrumbGraph( class UEdGraph* InGraph);

	/** Function to check whether the give graph is a subgraph */
	static bool IsASubGraph( const class UEdGraph* GraphPtr );

	/** Creates the SCSEditor tree component view and the SCS Viewport. */
	void CreateSCSEditors();

	/** Callback when a token is clicked on in the compiler results log */
	void OnLogTokenClicked(const TSharedRef<class IMessageToken>& Token);

	/** Helper function to navigate the current tab */
	void NavigateTab(FDocumentTracker::EOpenDocumentCause InCause);

	/** Find all references of the selected node. */
	void OnFindReferences();

	/** Checks if we can currently find all references of the node selection. */
	bool CanFindReferences();

	/** Called when the user generates a warning tooltip because a connection was invalid */
	void OnDisallowedPinConnection(const class UEdGraphPin* PinA, const class UEdGraphPin* PinB);

	/**
	 * Checks to see if the focused Graph-Editor is focused on a animation graph or not.
	 * 
	 * @return True if GraphEdPtr's current graph is an animation graph, false if not.
	 */
	bool IsEditingAnimGraph() const;

	/** Returns whether the currently focused graph is editable or not */
	bool IsFocusedGraphEditable() const;

	/** Called when the user wants to jump to a node's definition */
	void OnGoToDefinition();

	/** Checks to see if it is possible to jump to the selected node's definition. */
	bool CanGoToDefinition() const;

	/** Open documentation for the selected node class */
	void OnGoToDocumentation();

	/** Can we open documentation for the selected node */
	bool CanGoToDocumentation();

	/** Util to try and get doc link for the currently selected node */
	FString GetDocLinkForSelectedNode();

	/** Set the enabled state for currently-selected nodes */
	void OnSetEnabledStateForSelectedNodes(ENodeEnabledState NewState);

	/** Returns the appropriate check box state representing whether or not the selected nodes are enabled */
	ECheckBoxState GetEnabledCheckBoxStateForSelectedNodes();

	/** Attempt to match the given enabled state for currently-selected nodes */
	ECheckBoxState CheckEnabledStateForSelectedNodes(ENodeEnabledState CheckState);

	/** Handle undo/redo */
	void HandleUndoTransaction(const class FTransaction* Transaction);

public://@TODO
	TSharedPtr<FDocumentTracker> DocumentManager;

protected:

	// Should intermediate build products be saved when recompiling?
	bool bSaveIntermediateBuildProducts;

	/** Flags if this blueprint editor should close on its next tick. */
	bool bPendingDeferredClose;

	/** Currently focused graph editor */
	TWeakPtr<class SGraphEditor> FocusedGraphEdPtr;
	
	// Factory that spawns graph editors; used to look up all tabs spawned by it.
	TWeakPtr<FDocumentTabFactory> GraphEditorTabFactoryPtr;

	/** User-defined enumerators to keep loaded */
	TSet<TWeakObjectPtr<UUserDefinedEnum>> UserDefinedEnumerators;

	/** User-defined structures to keep loaded */
	TSet<TWeakObjectPtr<UUserDefinedStruct>> UserDefinedStructures;
	
	/** Macro/function libraries to keep loaded */
	TArray<UBlueprint*> StandardLibraries;

	/** SCS editor */
	TSharedPtr<class SSCSEditor> SCSEditor;

	/** Viewport widget */
	TSharedPtr<class SSCSEditorViewport> SCSViewport;

	/** Node inspector widget */
	TSharedPtr<class SKismetInspector> Inspector;

	/** defaults inspector widget */
	TSharedPtr<class SKismetInspector> DefaultEditor;

	/** Debugging window (watches, breakpoints, etc...) */
	TSharedPtr<class SKismetDebuggingView> DebuggingView;

	/** Palette of all classes with funcs/vars */
	TSharedPtr<class SBlueprintPalette> Palette;

	/** All of this blueprints' functions and variables */
	TSharedPtr<class SMyBlueprint> MyBlueprintWidget;
	
	/** Widget for replacing node references */
	TSharedPtr<class SReplaceNodeReferences> ReplaceReferencesWidget;

	/** Compiler results log, with the log listing that it reflects */
	TSharedPtr<class SWidget> CompilerResults;
	TSharedPtr<class IMessageLogListing> CompilerResultsListing;
	
	/** Find results log as well as the search filter */
	TSharedPtr<class SFindInBlueprints> FindResults;

	/** Merge tool - WeakPtr because it's owned by the GlobalTabManager */
	TWeakPtr<class SDockTab> MergeTool;
	/** Merge tool - Delegate to call when the merge tool is closed. */
	FOnMergeResolved OnMergeResolved;

	/** Reference to owner of the current popup */
	TWeakPtr<class SWindow> NameEntryPopupWindow;

	/** Reference to helper object to validate names in popup */
	TSharedPtr<class INameValidatorInterface> NameEntryValidator;

	/** Reference to owner of the pin type change popup */
	TWeakPtr<class IMenu> PinTypeChangeMenu;

	/** The toolbar builder class */
	TSharedPtr<class FBlueprintEditorToolbar> Toolbar;

	FOnSetPinVisibility OnSetPinVisibility;

	/** Has someone requested a deferred update of the saved document state? */
	bool bRequestedSavingOpenDocumentState;

	/** Did we update the blueprint when it opened */
	bool bBlueprintModifiedOnOpen;

	/** Whether to hide unused pins or not */
	SGraphEditor::EPinVisibility PinVisibility;

	/** Whether the graph action menu should be sensitive to the pins dragged off of */
	bool bIsActionMenuContextSensitive;
	
	/** The current UI selection state of this editor */
	FName CurrentUISelection;

	/** Whether we are already in the process of closing this editor */
	bool bEditorMarkedAsClosed;

	/** Blueprint preview scene */
	FPreviewScene PreviewScene;

	/** The preview actor representing the current preview */
	mutable TWeakObjectPtr<AActor> PreviewActorPtr;

public:
	// Tries to open the specified graph and bring it's document to the front (note: this can return NULL)
	TSharedPtr<SGraphEditor> OpenGraphAndBringToFront(UEdGraph* Graph);

	//@TODO: To be moved/merged
	TSharedPtr<SDockTab> OpenDocument(const UObject* DocumentID, FDocumentTracker::EOpenDocumentCause Cause);

	/** Finds the tab associated with the specified asset, and closes if it is open */
	void CloseDocumentTab(const UObject* DocumentID);

	// Finds any open tabs containing the specified document and adds them to the specified array; returns true if at least one is found
	bool FindOpenTabsContainingDocument(const UObject* DocumentID, /*inout*/ TArray< TSharedPtr<SDockTab> >& Results);


public:
	/** Broadcasts a notification whenever the editor needs associated controls to refresh */
	DECLARE_EVENT ( FBlueprintEditor, FOnRefreshEvent );
	FOnRefreshEvent& OnRefresh() { return RefreshEvent; }

private:
	/** Notification used whenever the editor wants associated controls to refresh. */
	FOnRefreshEvent RefreshEvent;

	/** Broadcast notification for associated controls to update */
	void BroadcastRefresh() { RefreshEvent.Broadcast(); }

	/** Command list for the graph editor */
	TSharedPtr<FUICommandList> GraphEditorCommands;

	/** Structure to contain editor usage analytics */
	struct FAnalyticsStatistics
	{
		/** Stats collected about graph action menu usage */
		int32 GraphActionMenusNonCtxtSensitiveExecCount;
		int32 GraphActionMenusCtxtSensitiveExecCount;
		int32 GraphActionMenusCancelledCount;

		/** Stats collection about user node creation actions */
		int32 MyBlueprintNodeDragPlacementCount;
		int32 PaletteNodeDragPlacementCount;
		int32 NodeGraphContextCreateCount;
		int32 NodePinContextCreateCount;
		int32 NodeKeymapCreateCount;
		int32 NodePasteCreateCount;

		/** New node instance information */
		struct FNodeDetails
		{
			FName NodeClass;
			int32 Instances;
		};

		/** Stats collected about warning tooltips */
		TArray<FDisallowedPinConnection> GraphDisallowedPinConnections;
	};

	/** analytics statistics for the Editor */ 
	FAnalyticsStatistics AnalyticsStats;

	/** Customizations for the SCS editor */
	TMap< FName, TSharedPtr<ISCSEditorCustomization> > SCSEditorCustomizations;

	/** Whether the current project is C++ or blueprint based */
	bool bCodeBasedProject;

	/** Delegates that are fired when the blueprint editor changes modes */
	FOnModeSet OnModeSetData;

	/** When set, flags which graph has a action menu currently open (if null, no graphs do). */
	UEdGraph* HasOpenActionMenu;
	/** Used to nicely fade instruction text, when the context menu is opened. */
	float InstructionsFadeCountdown;

	/** Handle to the registered OnActiveTabChanged delegate */
	FDelegateHandle OnActiveTabChangedDelegateHandle;

	// Allow derived editors to add command mappings 
	virtual void OnCreateGraphEditorCommands(TSharedPtr<FUICommandList> GraphEditorCommandsList) {}
};

#undef LOCTEXT_NAMESPACE
