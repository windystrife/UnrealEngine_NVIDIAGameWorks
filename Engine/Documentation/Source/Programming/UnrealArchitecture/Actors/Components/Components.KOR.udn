INTSourceChangelist:3108692
Availability:Public
Title: 컴포넌트
Crumbs:%ROOT%, Programming
Description:컴포넌트와 사용가능한 여러가지 유형에 대한 설명입니다.
Version: 4.9

[TOC (start:2 end:3)]


[EXCERPT:Overview]
**컴포넌트** (Component)란 **액터** 내 서브-오브젝트로 사용되도록 고안된 특수한 유형의 **오브젝트** 입니다. 
보통 쉽게 교체가능한 부속 형태로 소유중인 **액터** 의 특정 함수성이나 행위를 바꾸고자 할 때 사용됩니다. 예를 들어 차량의 이동 제어 방식은 비행기나 배와 다르지만, 
이 모두 일정한 공통성을 공유하는 비히클(vehicle, 탈것)입니다. 컴포넌트를 사용하여 그 이동 제어 방식을 조절하면, 같은 비히클은 해당 유형과 비슷하게 
작동하도록 쉽게 만들 수 있습니다.
[/EXCERPT:Overview]

일반적인 서브 오브젝트의 기본적인 행위와는 반대로, 컴포넌트는 액터 안에 서브-오브젝트로 생성되는 컴포넌트가 인스턴싱될 때, 특정 클래스의 각 **액터** 인스턴스는 
자체적으로 컴포넌트 고유 인스턴스를 갖습니다. 이것을 시각화시켜 볼 수 있는 한 가지 방법은, 위에서 설명한 비히클을 그려 보는 것입니다. **Car** 클래스가 차량의 바퀴를 나타내기 위해 컴포넌트를 사용할 수 있습니다. 
클래스의 default properties 에서 네 개의 **휠** 컴포넌트를 서브-오브젝트로 생성하여 `Wheels[]` 배열에 할당합니다. 
새로운 **Car** 인스턴스 생성시, 딱 그 **Car** 를 위한 휠 컴포넌트의 새 인스턴스들이 생성됩니다. 그렇게 하지 않는다면, 월드에 있는 **Car** 가 하나 움직일 때마다 모든 **Car** 의 휠이 돌게 될 텐데, 
바람직한 행위는 아닐 테지요. 기본적인 컴포넌트 인스턴싱 덕에 **액터** 에 고유 서브-오브젝트를 빠르게 추가하는 프로세스가 단순화됩니다.

[REGION:note]
**주:** 컴포넌트 인스턴싱이 없다면, 모든 컴포넌트 변수는 **[Instanced](Programming\UnrealArchitecture\Reference\Properties\Specifiers\Instanced) 변수 지정자** 로 선언해 줘야 할 것입니다.
[/REGION]

## 액터 컴포넌트

**ActorComponent** (액터 컴포넌트)는 다양한 유형의 **액터** 에 추가시킬 수 있는 재사용가능 행위를 정의하는 컴포넌트에 대한 베이스 클래스입니다. 이들은 일반적으로 지오메트리에 **액터** 를 
연관시키는 데 사용됩니다. 이를테면 콜리전 지오메트리나 렌더링된 메시 형태, **액터** 의 월드 이동 방식 제어, **액터** 와 연관시켜 소리 재생, 
**액터** 가 월드에 빛과 그림자를 드리우게 하는 능력 제공 등입니다. 사실 플레이어가 게임을 플레이할 때 월드에서 보고 듣고 만지는 모든 것은 사실 한 가지 이상의 **액터 컴포넌트** 작업 결과입니다. 
트랜스폼을 가진 **액터 컴포넌트** 는 **씬 컴포넌트** 라고 하며, 렌더링 가능한 것은 **프리미티브 컴포넌트** 라고 합니다.

### 컴포넌트 등록하기

**액터 컴포넌트** 를 매 프레임 업데이트시켜 씬에 영향을 끼치도록 하려면, 씬에 **등록** (register)시켜야 합니다. 등록은 `UActorComponent::RegisterComponent()` 를 호출하여 이루어집니다. 

	void UActorComponent::RegisterComponent()

이 함수는 `UActorComponent::RegisterComponentWithScene()` 를 호출하여 소유중인 **액터** 의 `Components[]` 배열에 **액터 컴포넌트** 가 들어있는지 확인하고, 
씬에 연관시킨 다음, **액터 컴포넌트** 에 대한 [렌더 프록시](#씬프록시) 와 [피직스 스테이트](#피직스스테이트) 를 만듭니다.

**액터 컴포넌트** 는 서브-오브젝트로 생성되고 **액터** 의 default properties 내 `Components[]` 배열에 추가된 경우, 소유중인 **액터** 가 스폰될 때 자동으로 등록됩니다. 
플레이 도중 `UActorComponent::RegisterComponent()` 를 호출하여 언제든 등록시킬 수는 있지만, 컴포넌트 등록은 약간 무거운 작업이라 꼭 필요할 때만 해 줘야 한다는 점, 
주의하시기 바랍니다.

#### 등록 이벤트

컴포넌트가 등록될 때, 아래와 같은 이벤트가 발동됩니다.

| 함수 | 설명 |
| ---- | ---- |
| UActorComponent::OnRegister() | 컴포넌트 등록시 필요에 따라 추가적인 초기화를 가능케 하는 이벤트입니다. |
| UActorComponent::CreateRenderState() | 컴포넌트에 대한 렌더 스테이트를 초기화시킵니다. |
| UActorComponent::OnCreatePhysicsState() | 컴포넌트에 대한 피직스 스테이트를 초기화시킵니다. |


### 컴포넌트 등록해제하기

**액터 컴포넌트** 를 등록해제(Unregister)하여 업데이트, 시뮬레이션, 렌더링을 중지시킬 수 있습니다. 컴포넌트 등록해제는 `UActorComponent::UnregisterComponent()` 호출을 통해 이루어집니다. 

	void UActorComponent::UnregisterComponent()

#### 등록해제 이벤트

컴포넌트가 등록해제될 때, 아래와 같은 이벤트가 발동됩니다.

| 함수 | 설명 |
| ---- | ---- |
| UActorComponent::OnUnRegister() | 컴포넌트 등록해제시 필요에 따라 추가적인 동작을 가능케 하는 이벤트입니다. |
| UActorComponent::DestroyRenderState() | 컴포넌트에 대한 렌더 스테이트를 소멸시킵니다. |
| UActorComponent::OnDestroyPhysicsState() | 컴포넌트에 대한 피직스 스테이트를 소멸시킵니다. |


### 업데이트하기

**액터 컴포넌트** 에는 그 `TickComponent()` 함수를 통한 매 프레임 업데이트 기능이 있습니다. 이를 통해 컴포넌트가 유형 고유의 프레임별 계산을 할 수 있습니다. 
예를 들어 **SkeletalMeshComponent** 는 애니메이션과 스켈레탈 콘트롤러를 업데이트하는 데 `TickComponent()` 를 사용하는 반면, **ParticleSystemComponent** 는 시스템의 이미터를 업데이트하고 처리할 파티클 이벤트 
검사에 사용합니다.

컴포넌트가 업데이트되도록 하려면 등록시켜 주고 틱 되도록 (`bComponentNeverTicks=false`) 설정한 다음 틱 함수를 셋업해 줘야 합니다. 

### 렌더 스테이트

**액터 컴포넌트** 가 렌더링되도록 하기 위해서는, 렌더 스테이트가 생성되어 있어야 합니다. **액터 컴포넌트** 의 렌더 스테이트는 컴포넌트의 렌더 데이터 업데이트가 필요할 만큼 
변화가 있었는지 엔진에 알려주기도 합니다. 그런 변화가 생기면, 렌더 스테이트에 더티 마킹이 됩니다. 그러면 현재 프레임 끝에서 모든 더티 컴포넌트의 렌더 데이터를 업데이트시킵니다.

### 피직스 스테이트

**액터 컴포넌트** 가 물리 엔진을 사용하여 시뮬레이션 되도록 하려면, 피직스 스테이트가 생성되어 있어야 합니다. 렌더 스테이트와는 달리, 피직스 스테이트는 더티 마킹될 일이 없는데, 
피직스는 변화가 발생하는 즉시 업데이트되기 때문입니다. 그래야 프레임이 뒤쳐지는 부작용이 발생하지 않기 때문에 중요합니다.

## 씬 컴포넌트

**씬 컴포넌트** (SceneComponent)는 **액터 컴포넌트** 에 트랜스폼, 즉 위치, 방향, 크기 정보를 추가시켜 확장한 것입니다. 트랜스폼을 추가했다는 것은, **씬 컴포넌트** 는 서로 붙이기(attach)도 할 수 있다는 
뜻입니다.

### 어태치먼트

언리얼 엔진 4 의 모든 어태치먼트(attachment)는 컴포넌트 수준에서 처리되며, 오직 **씬 컴포넌트** 만이 서로 붙일 수 있습니다. **씬 컴포넌트** 에는 `AttachParent` 프로퍼티가 있어서, 
어느 컴포넌트에 붙었는지를 나타냅니다. 주로 한 **액터** 에 여러 개의 컴포넌트가 들어있어 모두 붙어있게 만들고 싶을 때 사용됩니다. 그러나 다른 **액터** 에 속하는 컴포넌트를 지정하여, 
한 **액터** 속의 컴포넌트를 다른 **액터** 속의 컴포넌트에 붙이고자 할 때도 사용할 수 있습니다.

즉 한 **액터** 를 다른 액터에 붙이기 위해서, 그에 속한 **액터** 각각에는 최소 하나의 **씬 컴포넌트** 가 (실제로 붙는 것들은 이것들이니) 들어있어야 한다는 소리이며, 
붙이려는 **액터** 의 **씬 컴포넌트** 는 루트 컴포넌트여야 합니다. 그 이유는 명확합니다. 각 컴포넌트의 부모는 딱 하나 뿐이니 붙은 컴포넌트가 붙이려는 **액터** 의 루트 컴포넌트가 아니라면, 
해당 컴포넌트와 자손 컴포넌트는 붙게 될 유일의 컴포넌트가 됩니다. 루트 컴포넌트는 전체적으로 **액터** 처럼 붙지도 영향받지도 않은 채 남아있게 될 텐데, 
액터가 루트 컴포넌트와 그 트랜스폼에 의존하기 때문입니다.

### 컴포넌트 트랜스폼

`FTransform` 구조체에는 `Translation` 벡터, `Rotation` 쿼터니언, `Scale3D` 벡터가 들어있습니다. 각 *씬 컴포넌트** 자체에는 보통 내부용으로 쓰이는 `FTransform` 이 있어, 
월드 기준 위치, 방향, 크기를 기술합니다. 추가적으로 `RelativeLocation` 벡터, `RelativeRotation` 로테이터, RelativeScale3D` 벡터도 있어, 
부모 컴포넌트를 기준으로 할지 월드를 기준으로 할지 결정하도록 할 수 있습니다. 보통 컴포넌트에 대한 트랜스폼 정보를 구해오거나 설정할 때 사용되는 것입니다.

기본적으로 `RelativeLocation`, `RelativeRotation`, `RelativeScale3D` 는 그 `AttachParent` 를 기준으로 합니다. `bAbsoluteLocation`, `bAbsoluteRotation`, `bAbsoluteScale` 프로퍼티를 사용하면 이 값의 기준을 월드로 강제시킬 수 있습니다. 이 옵션 중 하나를 _True_ 로 설정하면 해당 프로퍼티는 월드를 기준으로 합니다.

부모를 기준으로 한 트랜스폼 값을 사용할 때도, 아래 표시된 메소드를 통해 절대 월드 값을 사용하여 트랜슬레이션과 로테이션을 설정하는 것도 여전히 가능한 일입니다:


| 함수 | 설명 |
| ---- | ---- |
| SceneComponent::SetWorldLocation() | 이 컴포넌트를 월드 스페이스 내 지정된 위치에 놓도록 상대 트랜슬레이션을 설정합니다. |
| SceneComponent::SetWorldRotation() | 이 컴포넌트를 월드 스페이스 내 지정된 방향으로 놓도록 상대 로테이션을 설정합니다. |

## 프리미티브 컴포넌트

**프리미티브 컴포넌트** 는 보통 콜리전 데이터로 사용되거나 렌더링되는 지오메트리 유형을 생성하거나 담는 **씬 컴포넌트** 입니다. 다양한 지오메트리 유형에 대한 서브클래스는 여럿 있으나, 
여지껏 가장 흔한 것은 **CapsuleComponent**, **StaticMeshComponent**, **SkeletalMeshComponent** 입니다. **CapsuleComponent** 는 충돌 감지에 쓰이나,
렌더링되지는 않는 지오메트리를 생성하는 데 사용되는 반면, **StaticMeshComponent** 와 **SkeletalMeshComponent** 는 렌더링 되면서 충돌 감지에 쓸 수도 있는 미리 빌드된 지오메트리가 들어갑니다.

### 씬 프록시

**프리미티브 컴포넌트** 의 `SceneProxy` 는 `FPrimitiveSceneProxy` 인스턴스로, 프리미티브 렌더링을 게임 스레드와 병행시키기 위해 미러링되는 씬 데이터를 캡슐화시킨 것입니다. 
각 프리미티브 유형마다 `FPrimitiveSceneProxy` 의 서브클래스를 생성, 해당 프리미티브 유형을 렌더링하는 데 필요한 렌더 데이터를 담습니다.

프리미티브와 지오메트리 렌더링 관련 자세한 내용은 [렌더링 시스템 개요](Programming/Rendering) 를 참고해 주시기 바랍니다.
