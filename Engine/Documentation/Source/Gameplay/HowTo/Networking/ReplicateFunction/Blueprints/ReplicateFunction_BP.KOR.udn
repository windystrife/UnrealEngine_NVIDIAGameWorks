INTSourceChangelist:3429254
Availability: Public
Title:블루프린트에서 함수 리플리케이트
Crumbs: %ROOT%, Gameplay, Gameplay\HowTo\Networking\ReplicateFunction
Description:블루프린트로 멀티플레이 게임에서 함수를 리플리케이트시키는 방법 안내입니다.
Related: Engine/Blueprints
Related: Resources/ContentExamples/Networking
Version: 4.9
SkillLevel: Advanced
type:how-to

[TOC (start:2 end:2)]

여기서는 여러가지 형태의 **리플리케이티드 함수** 구성 및 사용 방법을 보여드리겠습니다.

리플리케이티드 함수는 크게 **Multicast** (멀티캐스트), **Run on Server** (서버에서 실행), **Run on owning Client** (소유 클라이언트에서 실행), 총 세 가지 유형입니다. 멀티캐스트 함수는 실행되는 곳인 서버에서 호출된 다음, 클라이언트에 자동 전송됩니다. 서버 함수는 클라이언트에서 호출된 다음 서버에서만 호출됩니다. 클라이언트 함수는 서버에서 호출된 다음 소유 클라이언트에서만 실행됩니다.

## 멀티캐스트

 _이 예제에서는 **시작용 콘텐츠 포함 블루프린트 삼인칭 템플릿** 을 사용합니다._

 **멀티캐스트** 리플리케이티드 함수 설정 방법은 아래와 같습니다.
 
1.	**플레이** 버튼 옆의 아래 화살표를 클릭한 다음 플레이어 수를 **4** 로 설정하여 플레이어 수를 늘립니다.

	[REGION:raw]
	![](HowTo2.png)
	[/REGION]
	
	[REGION:tip]
	**고급 세팅** 옵션 안에서 멀티플레이용으로 생성되는 창의 크기를 변경할 수 있습니다.
	[/REGION]

1.	**콘텐츠 브라우저** 에서 **Content/ThirdPersonBP/Blueprints** 폴더 아래 **ThirdPersonCharacter** 블루프린트를 엽니다.

1.	그래프에 **우클릭** 한 다음 **Space Bar** Key Event 와 **Spawn Actor from Class** 노드를 추가합니다.

1.	**우클릭** 후 **Get Actor Transform** 노드를 추가하고 아래와 같이 연결한 뒤 **Class** 는 **Blueprint_Effect_Fire** 로 설정합니다. 

	![](HowTo3.png)

	키를 누르면 플레이어 캐릭터의 위치에 화염 이펙트를 스폰시킵니다.

1.	**컴파일** 및 **저장** 후 블루프린트를 닫은 뒤 **플레이** 버튼을 클릭하여 에디터에서 플레이합니다.

1.	게임에서 "서버" 창 위치를 찾은 다음 **스페이스 바** 를 눌러 점프합니다.
		
	![](HowTo4.png)
	
	서버 창에서만 화염 이펙트가 스폰되고 다른 플레이어에게는 그 이펙트 스폰이 안보이는 것이 보일 것입니다.
	다른 플레이어를 가지고 점프 시도를 하면, 마찬가지로 로컬에서는 화염 이펙트가 스폰되지만 다른 플레이어들은 그 이펙트 스폰 여부를 알지 못합니다.
	추가로, **Space Bar** 가 눌렸을 때만 캐릭터 위치에 스폰되도록 하기 위해서, 화염 이펙트를 캐릭터에 붙이지는 않았습니다.

	[REGION:tip]
	멀티플레이어 테스트 도중 **Shift + F1** 키를 누르면 마우스 콘트롤이 가능하여 게임 창을 돌아다닐 수 있습니다.
	[/REGION]

1.	**ThirdPersonCharacter** 블루프린트에서 **Space Bar** 노드의 **Pressed** 에 **우클릭** 한 다음 연결을 끊습니다.

1.	**우클릭** 후 **Custom Event** 를 검색 추가한 다음 **MulticastSpawn** 이벤트를 호출합니다.

1.	커스텀 이벤트에 클릭한 다음 **디테일** 패널에서 **Replicates** (리플리케이트) 드롭다운 메뉴를 **Multicaset** (멀티캐스트)로 설정하고 아래와 같이 연결합니다.

	![](HowTo5.png)

	위의 마지막 몇 단계에서는 커스텀 이벤트가 **멀티캐스트** 리플리케이션을 사용하도록 설정했습니다.

1.	**Space Bar** Key Event 를 끌어놓고, **MulticastSpawn** 함수를 검색 추가한 뒤 호출합니다.

	![](HowTo6.png)

	[REGION:note]
	만든 커스텀 이벤트가 보이지 않으면, **컴파일** 버튼을 클릭한 다음 다시 검색해 보세요.
	[/REGION]

1.	**컴파일**, **저장** 후 블루프린트를 닫고 **재생** 버튼을 클릭하여 에디터에서 플레이합니다.

1.	게임에서 "서버" 창 위치를 찾은 다음 **스페이스 바** 를 눌러 점프합니다.

	![](HowTo7.png)

	이제 서버인 플레이어를 가지고 점프를 누르면 화염 이펙트가 서버 뿐만 아니라 모든 클라이언트에서도 스폰되는 것이 보일 것입니다. 다른 플레이어로 점프를 해 보면 여전히 로컬에서만 이펙트가 스폰되는데, 클라이언트가 이펙트를 스폰했다고 서버에게 알리지 않았기 때문입니다. 다음에는 **Run on Server** (서버에서 실행)을 이용한 구성 방법을 보여드리도록 하겠습니다.


## 서버에서 실행

 _이번 예제에서는 위의 **멀티캐스트 리플리케이션** 예제를 이어가도록 하겠습니다._

 **Run on Server** (서버에서 실행) 리플리케이티드 함수 구성 방법은 다음과 같습니다.
 
1.	**콘텐츠 브라우저** 에서 **Content/ThirdPersonBP/Blueprints** 아래 **ThirdPersonCharacter** 블루프린트를 엽니다.

1.	**MulticastSpawn** Custom Event 를 선택한 다음 **Replicates** (리플리케이트) 드롭다운 옵션을 **Run on Server** (서버에서 실행)으로 변경합니다.

	![](HowTo8.png)
	
	편의상 **그래프 노트** 이름도 **Run On Server** 로 업데이트했습니다.

1.	**컴파일**, **저장** 후 블루프린트를 닫고 **플레이** 버튼을 클릭하여 에디터에서 플레이합니다.

1.	게임에서 **서버** 이외의 게임 창 위치를 찾은 다음 **스페이스 바** 를 눌러 점프합니다.

	![](HowTo9.png)

	어느 플레이어가 점프를 하든 상관없이 서버에서만 화염 이펙트가 스폰되고 다른 플레이어에게는 보이지 않는 것을 알 수 있습니다. 이 스크립트로 서버에서 실행하라고 일러주기는 했고, 또 그렇게 했지만, 이펙트 자체가 서버 뿐만 아니라 모든 클라이언트에게도 전달되도록 리플리케이트 설정을 해 줘야 할 필요가 있습니다.

1.	**Content/StarterContent/Blueprints** 폴더의 **Blueprint_Effect_Fire** 블루프린트를 엽니다.

1.	메인 툴바에서 **클래스 디폴트** 를 선택하고 **디테일** 패널에서 **리플리케이트** 박스를 체크합니다.

	![](HowTo10.png)

1.	**컴파일**, **저장** 후 블루프린트를 닫고 **플레이** 버튼을 클릭하여 에디터에서 플레이합니다.

1.	게임에서, **서버** 이외의 창을 찾은 다음 **스페이스 바** 를 눌러 점프합니다.

	![](HowTo11.png)

	액터가 리플리케이트 설정되어 있어, 서버에서 액터 스폰을 위한 스크립트 부분을 실행하라고 메시지가 실제로 전송되었고, 모든 클라이언트에서도 확인할 수 있습니다.
	

## 소유 클라이언트에서 실행

_이 예제에서는 위의 **멀티캐스트 리플리케이션** 예제를 이어갑니다._

이 예제에서는, 서버에서 이벤트가 생기면 특정 클라이언트에서만 업데이트되는 변수를 만들어 보겠습니다.

 **Run on owning Client** (소유 클라이언트에서 실행) 리플리케이티드 함수 구성 방법은 다음과 같습니다.
 
1.	**Content/ThirdPersonBP/Blueprints** 폴더의 **ThirdPersonCharacter** 블루프린트를 엽니다.

1.	**내 블루프린트** 창에서 변수를 새로 만든 다음 이름을 **Inventory** 라 하고 **컴파일** 합니다.

	![](Inventory.png)

1.	**컴파일** 후 변수의 **디테일** 패널에서 **Editable** (편집가능), **Replicated** (리플리케이티드) 설정을 하고, **Default Value** (기본값)에는 **Empty** 를 입력합니다.

	![](HowTo12.png)

	이 변수를 **Replicated** (리플리케이티드) 설정하면 접속된 머신에 네트워크를 통해 리플리케이트되도록 합니다. 이를 통해 멀티플레이어 게임에서 캐릭터가 트리거 볼륨에 들어서면 아이템을 줍고 트리거를 나서면 아이템을 제거하는 상황을 시뮬레이션 하겠습니다.

1.	**P** Key Event 를 추가하고 **Print String** 노드에 연결한 다음, **Control** 키를 누르고 **Inventory** 변수를 끌어놓아 다음과 같이 연결합니다.

	![](HowTo13.png)

1.	**컴파일**, **저장** 후 **ThirdPersonCharacter** 블루프린트를 닫습니다.

1.	**모드** 창에서 **기본** 아래 **박스 트리거** 를 끌어 레벨에 놓습니다.

	![](HowTo14.png)

	플레이어 캐릭터가 트리거에 들어서면, 우리가 만든 변수를 업데이트하되, 트리거 박스에 들어선 클라이언트만 업데이트합니다.

1.	**박스 트리거** 의 **디테일** 패널에서 **Rendering** 아래 **Actor Hidden In Game** (게임에서 액터 숨김) 체크를 해제합니다. 

	![](UnHideBox.png)

	그러면 에디터에서 플레이시 레벨의 박스를 확인할 수 있어 테스트가 수월해-집니다.

1.	**박스 트리거** 를 클릭하여 선택한 다음, 메인 툴바에서 **레벨 블루프린트** 를 엽니다.

	![](HowTo15.png)

1.	그래프에 **우클릭** 한 다음 **Begin Overlap** 을 검색한 뒤 **Add On Actor Begin Overlap** 이벤트를 선택합니다.

	![](HowTo16.png)

1.	전 단계를 반복하되, **Add On Actor End Overlap** 이벤트를 검색 추가합니다.

1.	각 노드를 **Switch Has Authority** 노드에 연결합니다.

	![](HowTo17.png)

	**Switch Has Authority** 노드는 현재 실행중인 스크립트가 어디서 실행되는지를 검사한 다음, 스크립트가 네트워크 **Authority** (오쏘리티, 보통 서버)에서 실행되는지 **원격** 머신 (클라이언트) 에서 실행되는지에 따라 두 방향으로 분기 가능합니다.
	
	종종 서버에서만 실행시키고자 하는 것에는 **Authority** 를 사용하게 됩니다 (보통 플레이어의 생명력 값 조정, 보상이나 아이템 루트 부여처럼 게임플레이에 중요해서 클라이언트에서의 변경을 허용하지 않음으로써 치트를 방지하고자 할 때 쓰입니다).

	이 예제에서는, 플레이어의 생명력이 저장된 변수나 수집한 아이템에 대한 변수가 될 수 있는 텍스트 변수를 업데이트하겠습니다.

1.	그래프에 **우클릭** 한 다음 **Add Item** 이라는 **Custom Event** 를 추가합니다.

1.	리플리케이트 옵션을 **Run on owning Client** (소유 클라이언트에서 실행)으로 설정하고, **Character** 라는 입력을 추가하여 **Actor** 라 설정합니다. 

	![](HowTo18.png)

	[REGION:note]
	노드 생성 후 오류 경고가 보이는 경우, **컴파일** 버튼을 누르면 오류가 제거됩니다.
	[/REGION]

1.	**Add Item** 이벤트와 똑같은 세팅으로 **Remove Item** 이라는 **Custom Event** 를 하나 더 만듭니다.

1.	두 개의 겹치는 이벤트에서 아래와 같이 **Add Item** 과 **Remove Item** 노드를 연결합니다.

	![](HowTo19.png)

	여기서는 트리거에 겹칠 때, 서버에서 오버랩이 발생한 경우, 서버에서 **Add Item** 이벤트를 실행한 뒤 (트리거에 겹치는 캐릭터인) 소유 클라이언트에 리플리케이트시킵니다. 여기서 리플리케이트시키는 것은 **Add Item** 이 발동되면 호출되는 스크립트로, 서버에서만 실행되나 클라이언트에 리플리케이트되는 것입니다. 캐릭터가 트리거 박스를 떠나면, 다시금 서버에 의해 결정되고, 서버에서 **Remove Item** 이벤트를 실행한 다음 소유 클라이언트에 리플리케이트 시킵니다.

1.	**Add Item** 이벤트에서 **Print String** 를 추가하고 (텍스트는 **Item Added** 로 설정), **Character** 를 끌어놓은 뒤 **Cast To ThirdPersonCharacter** 합니다. 

	![](HowTo20.png)

1.	**As Third Person Character** 핀을 끌어놓고 **Set Inventory** 노드를 검색 추가한 다음 Text 를 **Has the Item** 으로 설정합니다.

	![](HowTo21.png)

	여기서는 화면에 "Item Added" 를 출력하는 서버에서 실행, 클라이언트에 리플리케이트되는 이벤트를 받은 다음, 소유 클라이언트에 대한 **Inventory** 텍스트 변수를 **Has the Item** 으로 설정합니다.

1.	**Add Item** 이벤트 위의 세 노드를 복사한 다음 **Remove Item** 이벤트에 연결합니다.

1.	**Print String** 을 **Item Removed** 로 변경한 다음 **Inventory** 텍스트 변수를 **Empty** 로 변경합니다.

	![](HowTo22.png)

	이제 캐릭터가 트리거를 떠나면, 서버에서 텍스트 변수를 업데이트하고 소유 클라이언트에 리플리케이트시킵니다.

1.	**컴파일**, **저장** 후 **레벨 블루프린트** 를 닫고 에디터에서 플레이합니다.

	[OBJECT:EmbeddedVideo]
	[PARAMLITERAL:width]
	640
	[/PARAMLITERAL]
	[PARAMLITERAL:height]
	360
	[/PARAMLITERAL]
	[PARAMLITERAL:videoid]
	KiBrcLbXbYQ
	[/PARAMLITERAL]
	[/OBJECT]

	위 비디오에서 게임이 시작되면, **P** 를 눌러 텍스트 변수를 화면에 출력하여 각 캐릭터에 대해 "empty" 라 표시합니다. 하지만 캐릭터 중 하나가 트리거 박스에 들어서면, "Item Added" 텍스트가 표시됩니다. 캐릭터가 **P** 를 누르면 텍스트가 **Has the Item** 으로 바뀌는 반면 다른 캐릭터 각각은 여전히 "empty" 로 표시됩니다. 캐릭터가 박스를 떠나면, "Item Removed" 텍스트가 표시되고, **P** 를 다시 누르면 텍스트가 다시 **empty** 로 변경됩니다.

	이 예제는 서버에서 이벤트를 실행하고 그 이벤트를 개별 클라이언트에 리플리케이트시키는 방법을 보여줍니다.





	










	
