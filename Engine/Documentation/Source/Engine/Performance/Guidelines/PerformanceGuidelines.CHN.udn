INTSourceChangelist:2704361
Availability:Public
Title: 性能指南
Crumbs: %ROOT%, Engine
Description: 对于内容优化和关卡优化的通用提示和技巧
Navigation:topic
version: 4.9

我们针对内容制作和关卡设计在性能优化方面有一些通用的指南。

### 对美术而言

* 最小化每个物体的元素数量。
* 将模型合并，形成单个元素上有一定数量的三角面（比如每个元素 300+ 个三角面）。
* 不透明的材质性能最快，因为有最佳的 ZBuffer 裁剪，蒙版会稍慢一些，半透明则最慢，因为有多次绘制的开销。
* 限制 UV seam 的数量和 hard edges 的数量，因为它们会导致硬件计算时更多的顶点数据。在最糟的情形下，一些外部的建模软件计算下，具有大量多边形的模型采用 hard edge 可能会导致三倍于非 hard edge 的顶点数据。
* Skinned Mesh 的顶点处理通常都比 Static Mesh 的顶点处理要求更多的性能。
* 当添加了 Morph Target 或者使用 WorldPositionOffset 时，顶点处理需要更多的性能开销。由于缓存的原因，贴图的查找过程也会更慢。
* 曲面细分要求很多额外的性能开销，应该尽可能避免使用。预先细分好的模型通常会快得多。
* 较大的模型可以分为多个，以获得更好的裁剪优化。这不止对于可见性的裁剪，光照则在更细的粒度上被处理。
* 越小的贴图格式能带来更快的材质（比如 DXT1 是每像素 4 bit（即 4 bpp），DXT5 是 8 bpp，而 ARGB 则是 32 bpp）。
* 越低的贴图分辨率越快（当放大时）。有时也会更加平滑，因为双向线性过滤可以在 shade 层面比实际贴图展现得到更好的效果。
* 较少 shader 指令数的材质及贴图能运行的更快。优化材质的话，应使用材质编辑器中的 stat，以及在编辑器窗口中用 Shader 复杂度的视图模式。
* 如果一个贴图可以在较小的比例下被用到，应一直都为它采用 mipmaps，可以避免因为贴图缓存的未命中导致的性能下降。
* 有些材质表达式会比其他更花费性能（sin, pow, cos, divide, Noise）。最快的几个表达式是：multiply, add, subtract, 以及使用 0 和 1 的 clamp()。
* 着色模式本身具有一定的性能开销：无光模式最快，光照模式应该在大部分情况下使用。其他模式都会费一些。

### 对于关卡设计师而言

* 控制固定光照和动态光照的数量。
* 区域光照源会更费一些，应当在可能的情形下避免使用。
* 根据较小的物体来调整绘制距离，来达到更好的裁剪效果。
* 确认 LOD 是设置在一个比较激进的范围变化上。LOD 的顶点数通常应该是 2x 的变化。要做这个优化的时候，查看线框模式，一整块区域颜色就说明存在问题。使用整合的 Simplygon，这个过程很快的。
* 尽量将类似信息的光源合并。比如，车的头灯可以用一个光源以及一个光照函数让它看起来是两个灯的效果。
* 静态光照最快，固定光照稍慢一些，动态光照最慢。
* 按照需要，尽量限制光照的衰减半径以及光锥的角度。
* 动态/固定点光源是最费的。方向光源要稍好一些，最好的是聚光灯光源。阴影贴图生成的性能开销根据造成阴影的物体的光照锥体有关。
* 光照函数具有额外的性能开销（实际开销取决于材质），并能防止灯光被渲染成 Tiled Light。
* IES profiles 具有额外性能开销（比光照函数好一些），并能防止灯光被渲染成 Tiled Light。但不要在可以用聚光灯光锥就能完成效果的情形下，还使用 IES。
* Billboards，imposter meshes，或 skybox textures 都能用来代替实际的几何体物件并有效的提高性能。
* 好的关卡设计师能够将遮蔽裁剪纳入考虑优化关卡（添加一些阻挡视线的物件来提高性能）。使用 r.VisualizeOccludedPrimitives 可以直接查看。
* 避免使用 Light Propagation Volumes 或者通过使用 GIReplace 材质表达式来限制它，或者在带部分物件上禁用它。
* 在不需要的地方应该关闭阴影生成，一个个物件的关闭，或者一个个灯光来关闭。
* 在编辑器中使用 ProfileGPU（**Ctrl + Shift + ,**）快速了解信息以及哪部分比较慢。
* 贴花的性能开销和它们覆盖的像素数量有关。



![](Occluded.png)(w:813)

_CONSOLE: r.VisualizeOccludedPrimitives 1_
