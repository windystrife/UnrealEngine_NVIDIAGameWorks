INTSourceChangelist:3244370
Availability:Docs
Title:블루프린트 통신 비법
Crumbs: %ROOT%, Engine, Engine/Blueprints, Engine/Blueprints/UserGuide, Engine/Blueprints/UserGuide/BlueprintCommsUsage
Description:블루프린트 통신의 사양한 메소드 셋업 및 사용법 예제입니다.
tags:Blueprints

[TOC(start:2 end:4)]

여기서는 다양한 **블루프린트 통신** 메소드 셋업 방법을 단계별로 배워보도록 하겠습니다.

**블루프린트 통신** 각 유형을 언제 사용하는지에 대한 예제는, [](Engine\Blueprints\UserGuide\BlueprintCommsUsage) 문서를 참고하세요.

### 직접 블루프린트 통신

아래 레벨에 두 개의 **블루프린트** 에서 서로 통신을 했으면 합니다. 큐브 블루프린트에 플레이어가 들어서면 스파크 블루프린트더러 스스로를 끄라고 통신하고싶다 칩시다. **직접 블루프린트 통신** 을 통해 쉽게 가능합니다.

![](2_1.png)(w:400)

* 위 큐브는 **Shape_Cube** 메시를 사용하고 콜리전은 **OverlapOnlyPawn** 으로 설정하여 트리거 역할을 하도록 만든 **블루프린트** 입니다. **Generate Overlap Events** (오버랩 이벤트 생성)도 켭니다.
* 위의 스파크는 (시작용 콘텐츠에 포함된) **Blueprint_Effect_Sparks** 애셋입니다.

**직접 블루프린트 통신** 을 사용하여, 다음과 같은 작업을 합니다:

1. **Shape_Cube** 블루프린트에서 **MyBlueprint** 아래 Variables (변수) 카테고리의 ![](Engine\Blueprints\Editor\UIComponents\MyBlueprint\plus_Button.png) 버튼을 클릭합니다: ![](Engine\Blueprints\Editor\UIComponents\MyBlueprint\myblueprint_variable.png). 

1. **디테일** 패널에서 **변수 유형** 아래 접근하고자 하는 블루프린트 유형을 선택합니다.

	![](2_3.png)

	**Blueprint_Effects_Sparks** 변수 유형에 커서를 올리고 목록에서 **레퍼런스** 를 선택합니다.

	![](2_3_1.png)

	**Blueprint_Effect_Sparks** 블루프린트에 접근하고자 한다는 뜻입니다.

1. **디테일** 패널에서, 아래와 같이 업데이트합니다.
	
	![](2_4.png)

	1. **변수 이름** - **TargetBlueprint** 처럼 변수에 대한 설명이 되는 이름을 짓습니다.
	1. **변수 유형** - 접근하고자 하는 **블루프린트** 유형이 되어야 할 것입니다.
	1. **편집가능** - 이 옵션을 체크하고 변수를 노출시킨 뒤 퍼블릭으로 설정해 주면, 나중에 레벨 에디터에서 접근할 수 있습니다.
	1. **툴팁** - 변수가 하는 일 또는 가리키는 대상에 대한 짧은 설명을 추가합니다.

1. 레벨에 **Shape_Cube** 블루프린트를 선택한 채, 레벨 에디터에서 **디테일** 아래에 보면 예전 단계에서 만든 변수가 노출된 것이 보일 것입니다.

	![](2_6.png)

	1. **None** 드롭다운 박스를 클릭하여 **Target Blueprint** 를 할당합니다. 
	1. 레벨에 배치된 모든 블루프린트 인스턴스가 여기 표시되어, 어느 인스턴스가 **Target Blueprint** 인지 지정할 수 있습니다.

	여기서는 레벨에 배치된 **Blueprint_Effect_Sparks** 블루프린트 액터 중 어느 것에 영향을 끼치고자 하는지 나타내며, 이는 **인스턴스** 액터로 간주됩니다. 레벨에 스파크가 여러 개 있는데 그 중 하나만 끄고자 하는 경우, 그 블루프린트 인스턴스를 **Target Blueprint** 로 설정하면 됩니다.
			
1. 드롭다운을 사용하는 대신, ![](2_7.png) 아이콘을 클릭한 다음, 레벨에 배치된 오브젝트를 클릭해도 됩니다. 

	![](2_8.png)

	**Target Blueprint** 는 **변수 유형** 에 지정된 타겟으로만 (여기서는 **Blueprint_Effect_Sparks**) 설정할 수 있습니다.

1. **Shape_Cube** 블루프린트에서 **Ctrl** 키를 누른 채 변수를 초록에 끌어 놓습니다.

	![](2_9.png)

	1. 그러면 Get 노드가 추가되어, **타겟 블루프린트** 의 이벤트, 변수, 함수 등에 접근 가능합니다.
	1. 출력 핀을 끌어 놓아 맥락 메뉴를 띄웁니다.
	
	여기서 **Target Blueprint** 에서 스파크 이펙트와 스파크 오디오 컴포넌트를 검색하여 접근하고자 합니다.
	
1. 아래 샘플 스크립트는 플레이어가 큐브에 들어서면, 스파크 이펙트와 스파크 오디오를 비활성화시키는 것을 나타냅니다.

	![](2_10.png)(w:620)


#### 스폰된 액터에 대한 직접 블루프린트 통신

두 블루프린트 사이에 통신을 하고는 싶으나, 그 블루프린트 중 하나( 또는 둘 다)가 레벨에 배치되지 않은 상태일 수가 있습니다 (예를 들어 플레이어가 버튼을 누르면 스폰되는 마법 이펙트). 그 경우 플레이어 캐릭터도 마법 이펙트도 레벨에 스폰되지 않은 상태이므로, 위와 같은 **Target Blueprint** 와 인스턴스 설정은 불가능합니다.

 **Spawn Actor from Class** 노드를 사용할 때, 그 **Return Value** 를 끌어 놓은 다음 변수로 할당할 수 있습니다.

![](spawn1.png)(w:720)

아래 예제의 **MyCharacter** 블루프린트에서는, **F** 키가 눌리면 플레이어 위치에 **Blueprint_Effect_Smoke** 블루프린트 인스턴스를 스폰시킨 다음 **Target Blueprint** 라는 변수에 할당시킵니다.

![](spawn2.png)(w:880)

그런 다음 (위에서 노랑 박스에 들어있는) **Blueprint_Effect_Smoke** 블루프린트에 접근하여 우리 **Target Blueprint** 에서 Smoke Effect 와 Smoke Audio 컴포넌트를 구한 다음 **F** 키가 두 번째 눌리면 **Deactivate** 시킵니다 (바로 **Flip/Flop** 노드의 역할이지요). 즉 **직접 블루프린트 통신** 을 통해 한 블루프린트 안에서 다른 블루프린트에 접근하는 것입니다.

자세한 정보는 [](Engine\Blueprints\UserGuide\BlueprintComms) 문서를 참고하세요.


### 블루프린트 형변환

[EXCERPT:CastExample]

이 예제에서는, 레벨에 (액터인) 화염 이펙트 블루프린트가 있고, 그것이 플레이어가 사용하는 플레이가능 **캐릭터 블루프린트** 와 통신하도록 하고 싶습니다. 플레이어가 화염에 들어서면, **캐릭터 블루프린트** 에 플레이어가 화염에 들어서서 대미지를 받아야 한다는 신호를 보내고자 합니다. **OverlapEvent** 의 **Return Value** 를 사용하여 우리 **캐릭터 블루프린트** 에 **Cast To** (형변환)시키면 그 안의 이벤트, 함수, 변수에 접근할 수 있습니다.

 ![](3_0a.png)

* 위의 화염 이펙트는 (시작용 콘텐츠에 포함된) **Blueprint_Effect_Fire** 애셋입니다.
* **Trigger** 라는 이름의 구체 컴포넌트가 블루프린트에 추가되어 콜리전이 **OverlapOnlyPawn** 으로 설정되었습니다.

 **블루프린트 형변환** 을 사용하여, 다음과 같은 작업을 해 줍니다:

1. **Default Pawn Class** 에 할당된 **캐릭터 블루프린트** (플레이 가능 캐릭터)가 접근하고자 하는 **타겟 블루프린트** 입니다.

	![](3_0b.png)

	**Default Pawn Class** 는 **편집** - **프로젝트 세팅** 의 **맵 & 모드** 섹션에서 확인할 수 있습니다.

1. 이제 우리 타겟이 **MyCharacter** 블루프린트임을 알았으니, 플레이어가 **Is on Fire** (불이 붙었는지) 나타내는 **불리언** 변수를 만듭니다.

	![](3_0c.png)

	위에서 **Every Tick** 은 **분기** 에 물려 **True** 인 경우 **Apply Damage** 를 화면에 출력합니다 (True 다음이 대미지 적용 스크립트가 있을 곳입니다).

1. **Blueprint_Effect_Fire** 블루프린트 안에서, **트리거** 에 대한 두 개의 이벤트, **OnComponentBeginOverlap** 와 **OnComponentEndOverlap** 를 추가합니다. 

	![](3_1.png)

1. 이벤트를 추가한 상태로, **Other Actor** 핀을 끌어 놓은 다음 검색창에 **Cast To My** 를 입력합니다.

	![](3_2.png)(w:640)

	여기서 이벤트를 발동시키고자 하는 액터 (MyCharacter 블루프린트)를 검사/할당한 다음 **Cast To** 시켜서 화염 블루프린트에서 접근할 수 있도록 해 줬습니다.

1. **Cast To MyCharacter** 옵션을 선택합니다.

1. 노드를 추가한 상태로, **As My Character C** 핀을 끌어 놓으면 그 안의 이벤트, 변수, 함수 등을 접근할 수 있습니다 (이 경우 **Set Is on Fire**).

	![](3_3.png)(w:800)

1. **Blueprint_Effect_Fire** 블루프린트의 두 이벤트 모습은 이럴 것입니다.

	![](3_4.png)(w:640)

	불에 겹치면 **MyCharacter** 블루프린트의 **IsOnFire** 변수를 **True** 로 설정하고, 더이상 겹치지 않으면 **False** 로 설정합니다.
	**MyCharacter** 블루프린트 안에서, 화염 블루프린트를 통해 **IsOnFire** 가 **True** 로 설정되면, 화면에 **Apply Damage** 를 출력합니다 (아니면 헬쓰/대미지 시스템이 있는 경우, 대미지를 적용하여 플레이어의 헬쓰를 깎을 수도 있습니다).

[/EXCERPT:CastExample]

#### 다른 형변환 유형

[EXCERPT:OtherCasting]

다른 **블루프린트** 분류로 **Cast To** (형변환)하는 데 사용 가능한 특수 함수가 몇 가지 있습니다.

![](OtherCasting.png)(w:740)

위 예제 그래프에서, 다음과 같은 예제가 주어집니다:

| 블루프린트 | 설명 |
| -- | -- |
| **Character** (1) | **Get Player Character** 노드가 사용되어 **MyCharacter** 라는 캐릭터 블루프린트로 형변환하고 있습니다. |
| **PlayerController** (2) | **Get Player Controller** 노드가 사용되어 **MyController** 라는 플레이어 콘트롤러 블루프린트로 형변환하고 있습니다. |
| **Game Mode** (3) | **Get Game Mode** 노드가 사용되어 **MyGame** 이라는 게임 모드 블루프린트로 형변환하고 있습니다. |
| **Pawn** (4) | **Get Controlled Pawn** 과 **Get Player Controller** 노드가 사용되어 **MyPawn** 이라는 폰 블루프린트로 형변환하고 있습니다. |
| **HUD** (5) | **Get HUD** 와 **Get Player Controller** 노드가 사용되어 **MyHUD** 라는 HUD 블루프린트로 형변환하고 있습니다.  |

위 각각의 예제에서 **As My X** (X 는 블루프린트 유형) 노드를 끌어 놓는 것으로, 그 각각의 블루프린트에서 이벤트, 변수, 함수 등을 접근할 수 있습니다.

또 한 가지, **Get Player Character** 와 **Get Player Controller** 노드의 **Player Index** 값을 사용하여 멀티플레이어 상황에서 각기 다른 플레이어를 지정할 수 있습니다. 싱글 플레이어의 경우 얘들은 0 으로 놔둬도 됩니다.

[/EXCERPT:OtherCasting]

#### 타겟 블루프린트 형변환

[EXCERPT:TargetCasting]

변수를 특정 유형 블루프린트로 Cast To (형변환)해 줘야 접근할 수 있는 경우도 있습니다.

![](CreateCasting.png)

위 그림에서 1 번의 경우, **Save Game Object** 가 생성되어 **SaveGameObject** 변수에 할당됩니다. 그리고 그 변수가 **MySaveGame** 이라는 세이브 게임 블루프린트로 형변환하는 데 사용되어, 최고 점수, 최고 기록 등의 세이브 게임 정보를 전달 또는 받을 수 있습니다.

위 그림에서 2 번의 경우, **위젯 블루프린트** 를 생성하여 **UserWidget** 변수에 할당합니다. 그 변수가 **MyWidgetBlueprint** 라는 위젯 블루프린트로 형변환하는 데 사용되어, (HUD 또는 다른 UI 요소가 될 수도 있는)위젯 블루프린트에서 정보를 업데이트하거나 받을 수 있습니다. 

[/EXCERPT:TargetCasting]

### 이벤트 디스패처
아래 레벨에 있는 덤불 액터 **블루프린트** 는, 플레이어가 덤불에 불을 붙이는 버튼을 누르면 **캐릭터 블루프린트** 에서 통신을 받아, 몇 초 뒤 불과 덤불을 소멸시키도록 합니다. **캐릭터 블루프린트** 에서 **레벨 블루프린트** 로 통신을 하고자 하는데, **이벤트 디스패처** 를 통해 가능합니다.

![](Event1.png)(w:340)

* 위의 덤불은 (시작용 콘텐츠에 포함된) **SM_Bush** 애셋입니다.

**이벤트 디스패처** 를 사용하여 다음과 같은 작업을 해 줍니다:

1. **MyCharacter** 블루프린트 안에서 **이벤트 디스패처** 아이콘을 (숨겨져 있어 안보이는 경우 >> 버튼을 누른 다음) 클릭합니다. 이름은 **StartFire** 라 짓습니다.

	![](Event2.png)

1. 그래프에 **우클릭** 한 다음 **F** 키 이벤트를 추가하고, **Pressed** 를 끌어 놓은 다음 **Call StartFire** 이벤트 디스패처를 검색하여 추가합니다.

	![](Event3.png)

1. **MyBlueprint** 를 **컴파일**, **저장** 후 닫습니다. 

1. 레벨에 있는 덤불을 클릭하여 선택한 다음, **레벨 블루프린트** 를 엽니다.

	![](Event4.png)

1. 그래프에 **우클릭** 하고, 레벨에 있는 덤불로의 레퍼런스를 추가합니다.

	![](Event5.png)

1. **우클릭** 후 **Event Begin Play** 노드와 **Get Player Character** 노드를 추가한 다음, **Get Player Character** 를 **Cast To MyCharacter** 합니다.

	![](Event6.png)

1. **As My Character C** 를 끌어놓고 **Start Fire** 이벤트 디스패처를 할당합니다 (바인딩된 이벤트가 새로 생성됩니다).

	![](Event7.png)

1. **StartFire_Event** 를 끌어놓고 **SpawnActorFromClass** 노드를 추가한 다음 (클래스는 **Blueprint_Effect_Fire** 로 설정) **Transform** 에는 **SM_Bush** 트랜스폼을 구해줍니다.

	![](Event8.png)(w:800)

1. Spawn Actor 노드의 **Return Value** 을 끌어 놓은 다음 **Assign On Destroyed** 노드를 추가합니다.

1. **OnDestroyed_Event** 를 끌어놓고 **Destroy Actor** 노드를 추가하여 타겟은 **SM_Bush** 로 합니다.

1. **Bind Event to OnDestroyed** 를 끌어놓고 **Delay** (3 초) 를 추가한 다음 **Destroy Actor** 를 추가한 뒤 타겟은 Spawn Actor 노드의 **Return Value** 로 합니다.

	![](Event9.png)(w:840)

	요 몇 단계 결과는 위 그래프와 같습니다.

컴파일, 저장 후 에디터에서 플레이하고, **F** 키를 누르면 덤불 안에서 화염 이펙트가 스폰되는 것을 볼 수 있습니다. 3 초 후 화염과 덤불 모두 레벨에서 제거됩니다.

이는 물론 단순한 예제로, 플레이어가 덤불 근처에 있어야 불을 붙일 수 있도록 한다든가, 불은 한 번만 붙일 수 있다든가 등등, 보다 많은 검사를 했으면 좋을 것입니다. 하지만 **캐릭터 블루프린트** 에서 **이벤트 디스패처** 를 사용하여 **레벨 블루프린트** 안의 이벤트를 실행하는 법을 보여주는 데는 충분합니다. 스폰된 액터에 **이벤트 디스패처** 를 할당하여, 그 액터에 무슨 일이 생겼을 때 (여기서는 소멸되었을 때) 이벤트를 실행하도록 하는 법도 보여주고 있습니다.

자세한 정보는 [](Engine\Blueprints\UserGuide\EventDispatcher) 문서를 참고하세요.


### 블루프린트 인터페이스
아래에는 레벨에 **블루프린트** 가 넷 있습니다: 트리거 역할을 하는 큐브, 화염 이펙트, 스파크 이펙트, 그리고 매달린 라이트 입니다. 라이트와 스파크 각각은 플레이어가 큐브에 들어섰을 때 각기 다른 일을 하도록 하고 싶습니다. 큐브에 들어갈 때마다 캐릭터의 이동 속력을 올리고도 싶습니다.

![](Interface1.png)(w:420)

* 위의 큐브는 **Shape_Cube** 메시를 사용하고 콜리전을 **OverlapOnlyPawn** 으로 설정하여 트리거 역할을 하도록 만든 블루프린트 입니다.
* 위의 스파크는 (시작용 콘텐츠에 포함된) **Blueprint_Effect_Sparks** 애셋입니다.
* 위의 화염은 (시작용 콘텐츠에 포함된) **Blueprint_Effect_Fire** 애셋입니다.
* 위의 라이트는 (시작용 콘텐츠에 포함된) **Blueprint_CeilingLight** 애셋입니다.

**블루프린트 인터페이스** 를 사용하면 플레이어 캐릭터 블루프린트 뿐만 아니라 세 개의 블루프린트와도 통신할 수 있을 것입니다.

각각의 통신을 위해서는 다음과 같이 해 줍니다:

1. **콘텐츠 브라우저** 에서 빈 공간에 **우클릭** 한 다음 **블루프린트** - **블루프린트 인터페이스** 를 선택합니다.

	![](Interface2.png)(w:540)

1. 인터페이스 이름을 **CubeInterface** 식으로 지어준 다음 **더블클릭** 하여 열고 **함수 추가** 버튼을 클릭합니다.

	![](Interface3.png)

1. 새 함수 이름은 **MagicCube** 정도로 지어주고서, **컴파일**, **저장** 후 인터페이스를 닫습니다.

1. 큐브 블루프린트를 연 다음 **스태틱 메시** 에 우클릭한 뒤 **OnComponentBeginOverlap** 이벤트를 추가합니다.

	![](Interface4.png)

1. **Targets** 라는 **액터** 변수를 새로 만든 다음, 변수 유형 옆의 박스를 클릭하고 **배열** 로 만들어 준 뒤 **편집가능** 박스를 체크합니다.

	![](Interface5.png)

	**블루프린트 인터페이스** 영향을 받은 액터가 저장됩니다.

1. 그래프에 **우클릭** 한 다음 **인터페이스 메시지** 아래, **MagicCube** (또는 아까 지은 이름)를 클릭합니다.

	![](Interface6.png)

1. 그래프를 아래와 같이 구성한 다음, **컴파일**, **저장** 후 블루프린트를 닫습니다.

	![](Interface7.png)(w:640)

	**Targets** 변수를 끌어 놓은 다음, 거기에 **Add** 노드를 추가합니다.

	**Targets** 를 **MagicCube** 노드에 연결하고, **Get Player Character** 노드를 **Add** 노드에 연결합니다.

1. 레벨에서 큐브를 선택하고, **디테일** 패널에서 타겟 아래 + 부호를 클릭한 다음 레벨에 있는 화염, 라이트, 스파크를 추가합니다.

	![](Interface8.png)

1. **Blueprint_Effect_Fire** 블루프린트를 열고, 툴바에서 **블루프린트 속성** 버튼을 클릭합니다.

	![](Interface9.png)

1. **디테일** 패널에서 **인터페이스** 아래, **추가** 버튼을 클릭하고 인터페이스 (여기서는 **CubeInterface_C**) 를 선택합니다.

	![](Interface10.png)

1. 그래프에 **우클릭** 한 다음 **이벤트 추가** 아래, **Event Magic Cube** 이벤트를 선택합니다.

	![](Interface11.png)

1. **Event Magic Cube** 뒤에 오는 것은 무엇이든 플레이어가 큐브에 들어설 때 실행될 것입니다.

	![](Interface12.png)

	플레이어가 큐브에 들어서면 화염의 크기가 커진 다음, 두 번째 들어서면 리셋시킵니다.

1. **Blueprint_CeilingLight** 블루프린트를 열고 **블루프린트 속성** 버튼을 누른 다음 전과 같이 **디테일** 패널에서 인터페이스를 추가합니다.

1. 그래프에 **우클릭** 하고 **Event Magic Cube** 이벤트를 추가하여 플레이어가 큐브에 들어서면 이벤트 다음의 것이 실행되도록 합니다.

	![](Interface15.png)

	라이트의 Brightness 를 0 으로 설정하여 라이트를 끄고, 1500 으로 설정하여 켜고 있습니다.

1. **Blueprint_Effect_Sparks** 블루프린트에도 **블루프린트 속성** 추가를 반복하여 **CubeInterface_C** 를 추가합니다.

	![](Interface13.png)(w:720)
	
	큐브에 들어설 때 스파크 이펙트를 위로 이동시킨 다음, 두 번째 들어설 때 아래로 이동시킵니다.

1. **MyCharacter** 블루프린트에 **블루프린트 속성** 을 추가하는 작업을 반복한 다음 **CubeInterface_C** 를 추가합니다. 

	![](Interface14.png)

	큐브에 들어설 때마다 캐릭터의 이동 속력을 100 씩 증가키시고 있습니다.

위 예제에서 볼 수 있듯이, **블루프린트 인터페이스** 를 사용하면 각기 다른 블루프린트 유형과 단번에 통신할 수 있으며, 동일한 소스(여기서는 트리거)를 통해 각기 다른 함수를 수행하도록 할 수 있습니다.

이 예제는 하나의 이벤트로 다수의 블루프린트에 있는 함수성을 실행시키는 데 좋지만, **블루프린트 인터페이스** 를 사용하는 유일한 방식은 아닙니다. 다음 섹션에서는 **블루프린트 인터페이스** 를 사용하여 변수를 전달하는 법을 알아보겠습니다.

#### 블루프린트 인터페이스를 통해 변수 전달하기

아래 **Blueprint_Effect_Fire** 블루프린트에는 플레이어 캐릭터의 생명력을 나타냅니다.

이 블루프린트는 플레이어의 생명력이 얼마인지 검사하여 0 이 되면, 녹아 사라집니다.

![](InterfaceExample2_1.png)(w:420)

* 위의 화염은 (시작용 콘텐츠에 포함된) **Blueprint_Effect_Fire** 애셋입니다.

**블루프린트 인터페이스** 를 사용하여 두 변수(플레이어의 생명력과 플레이어가 죽었는지 아닌지)를 전달함으로써 화염 소멸 시기를 알려줄 수 있습니다.

그 변수 전달 관련 셋업 방식은 이렇습니다:

1. **콘텐츠 브라우저** 에서 빈 공간에 **우클릭** 한 다음 **블루프린트** - **블루프린트 인터페이스** 를 선택합니다.

	![](Interface2.png)(w:540)

1. 인터페이스 이름을 **BP_Interface** 정도로 지은 다음 **더블클릭** 하여 열어주고, **함수 추가** 버튼을 누릅니다.

	![](Interface3.png)

1. 새로운 함수 이름은 **GetHealth** 라 지어주고, **디테일** 패널에서 **추가** 버튼을 클릭하여 **출력** 을 두 개 추가합니다.

1. 새 출력 중 하나는 **불리언** 변수 **playerIsDead** 로 만들어 주고, 나머지 하나는 **플로트** 변수 **playerHealth** 라 해 준 뒤, 인터페이스를 **컴파일**, **저장** 후 닫습니다.

	![](InterfaceExample2_2.png)

1. **MyCharacter** 블루프린트를 열고, 툴바에서 **블루프린트 속성** 버튼을 클릭합니다.

	![](Interface9.png)

1. **디테일** 패널에서 **인터페이스** 아래 **추가** 버튼을 클릭한 다음 인터페이스(여기서는 **BP_Interface_C**) 를 선택합니다.

	![](InterfaceExample2_3.png)

1. **불리언** 변수 **OutOfHealth** 와 **플로트** 변수 **PlayerHealthValue** 를 만든 다음 **컴파일** 하고, **PlayerHealthValue** 를 **100** 으로 설정합니다.

1. **내 블루프린트** 의 **인터페이스** 섹션 아래 **GetHealth** 함수를 **더블클릭** 하여 엽니다.

1. 그래프에서 **OutOfHealth** 와 **PlayerHealthValues** 를 끌어 놓은 다음 아래와 같이 **ReturnNode** 에 연결합니다.

	![](InterfaceExample2_5.png)

	그러면 **MyCharacter** 블루프린트에 저장된 값이 인터페이스에 전달됩니다.

1. **MyCharacter** 블루프린트의 **이벤트 그래프** 로 돌아가서 아래 셋업을 다시 만들어 줍니다.

	![](InterfaceExample2_6.png)(w:800)

	플레이어의 생명력이 0 보다 크고 플레이어가 **F** 를 누르면, 현재 생명력 값에서 25 를 뺀 다음 **TakeDamage**  라는 **이벤트 디스패처** 를 호출합니다. 
	생명력이 0 이하라면 OutOfHealth 라는 불리언 변수를 _True_ 로 설정하고, **TakeDamage** 라는 **이벤트 디스패처** 를 호출합니다. 여기서 **이벤트 디스패처** 를 사용하여 다른 블루프린트에게 플레이어가 대미지를 입었음을 알릴 뿐, 다른 블루프린트에서 Event Tick 을 사용하여 매 틱마다 플레이어의 생명력을 검사하도록 하지는 않습니다.

1. 변수를 전달하고자 하는 블루프린트 (**Blueprint_Effect_Fire**) 를 열고, **디테일** 패널을 통해 인터페이스를 추가합니다.

	![](InterfaceExample2_3.png)

1. **이벤트 그래프** 에서 이벤트를 **MyCharacter** 블루프린트의 **TakeDamage** 이벤트에 바인딩합니다.

	![](InterfaceExample2_7.png)

	**Get Player Character** 노드를 끌어 놓고 **Cast To MyCharacter** 한 다음, **As My Character C** 를 끌어 놓고 **Assign Take Damage** 하여 바인딩된 이벤트를 만듭니다.

1. **TakeDamage_Event** 바인딩된 이벤트를 끌어 놓고, **GetHealth** 인터페이스 메시지를 추가합니다.

	![](InterfaceExample2_8.png)

	잊지 말고 **인터페이스 메시지** 를 구현하되, **함수 호출** 은 아닙니다.

1. 아래 셋업을 다시 생성합니다.
	
	[REGION:lightbox]
	[![](InterfaceExample2_9.png)(w:840)](InterfaceExample2_9.png)
	[/REGION]

	_이미지를 클릭하면 원래 크기로 보입니다._
	
	여기서 **GetHealth** 인터페이스가 일련의 **분기** 노드로 연결되어 먼저 (**MyCharacter** 블루프린트에 정의되어 있는) **PlayerIsDead**, 플레이어가 죽었는지 검사하고, 그렇다면 화면에 텍스트를 출력하고서 화염 이펙트/오디오를 비활성화시킵니다.

	두 번째 **분기** 노드는 **PlayerHealth** 값이 0 인가 검사하고, 그렇다면 캐릭터가 한 대만 더 맞으면 죽는다고 화면에 출력해 줍니다. 전혀 제대로 된 생명력/대미지 시스템은 아닙니다만, 인터페이스를 통해 두 변수를 전달하는 법이나 다른 블루프린트에서 그 변수를 사용하는 법을 보이기에는 충분할 것입니다. 이 예제의 "PlayerHealth" 값은 HUD 에 전달하여 현재 생명력을 반영하도록 할 수도 있습니다.

자세한 정보는 [](Engine\Blueprints\UserGuide\Types\Interface) 문서를 참고하세요.


